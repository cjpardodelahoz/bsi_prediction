---
title: "Dynamics of *Enterococcus* diversity"
engine: knitr
format:
  html:
    code-fold: true
    code-summary: "Show the code"
---

Potential talk title: Tracking down *Enterococcus* gut colonization with strain-resolved metagenomics

This is an initial exploration of the dynamics of *Enteroccocus* diversity in the HCT patient population. I have the following goals:

 - Stratify patients with *Enterococcus* dominations between those who did and did not get *Enterococcus* infections.
 - Link 16S ASVs to full-length 16S sequences assembled from metagenomes and the corresponding species identities.
 - Characterize genome-level strain diversity of *Enterococcus* across all samples with metagenomes
 - Determine whether dominating strains of *Enterococcus* colonize before or after hospitalization for HCT
 - Quantify *Enterococcus* strain sharing between patients
 - Quantify *Enterococcus* strain diversity within patients and through time during dominations

 ## Summary of dominations and inections
 
 It is already

```{r}
# Load required libraries and functions
suppressMessages(library(tidyverse))
source("code/rfunctions/data_helpers.r")

# Prepare genus-level counts
tblrel_genus_meta <- prep_taxa_counts("genus")

# Summarize patients with Enterococcus dominations and infections
summary_data <- tblrel_genus_meta %>%
  group_by(PatientID) %>%
  summarize(
    ever_dominated = any(Enterococcus_abund >= 0.3, na.rm = TRUE),
    ever_infected = any(Enterococcus_infection == TRUE, na.rm = TRUE)
  )

# Prepare data for plotting
plot_summary_data <- summary_data %>%
  mutate(
    domination_status = ifelse(ever_dominated, "Dominated", "Not Dominated"),
    infection_status = ifelse(ever_infected, "Infected", "Not Infected")
  ) %>%
  group_by(domination_status, infection_status) %>%
  summarize(count = n(), .groups = "drop")

# Create the bar plot
ggplot(plot_summary_data, aes(x = domination_status, y = count, fill = infection_status)) +
  geom_bar(stat = "identity", position = "stack") +
  geom_text(aes(label = count), position = position_stack(vjust = 0.5), color = "black") +
  scale_fill_manual(
    values = c("Infected" = "#0D7E2B", "Not Infected" = "gray75")
  ) +
  labs(
    x = "Domination status",
    y = "Number of patients",
    fill = "Infection status"
  ) +
  theme(legend.position = "top") +
  custom_theme

# Save the plot
ggsave("document/plots/enterococcus_domination_infection.pdf", height = 5, width = 3.8)
```

Now,

```{r}
# Load sample metadata
tblASVsamples <- read_csv("data/tblASVsamples.csv")

# Filter for patients who got dominated and infected with at least one AccessionShotgun
dominated_infected <- summary_data %>%
  filter(ever_dominated, ever_infected) %>%
  inner_join(tblASVsamples, by = "PatientID") %>%
  filter(!is.na(AccessionShotgun)) %>%
  pull(PatientID) %>%
  unique()

# Filter for patients who got dominated but not infected with at least one AccessionShotgun
dominated_not_infected <- summary_data %>%
  filter(ever_dominated, !ever_infected) %>%
  inner_join(tblASVsamples, by = "PatientID") %>%
  filter(!is.na(AccessionShotgun)) %>%
  pull(PatientID) %>%
  unique()

# Print the results
dominated_infected
dominated_not_infected
```


### Get patient MRNs to get access to additional metagenomic data

I needed to give Angel the MRNs of the patients that I'm interested in to see if I can get access to aditional metagenomic data that is not yet published:

```{r}
# Load the patient dictionary
patient_dictionary <- suppressMessages(
  read_csv("data/tCastoriPatientDictionaryWithDatesAndOtherStudiesPatientId.txt")
)

tblhctmeta <- read_csv("data/tblhctmeta.csv")

# Filter tblASVsamples for patients with no AccessionShotgun
patients_no_shotgun <- tblASVsamples %>%
  filter(is.na(AccessionShotgun) & between(DayRelativeToNearestHCT, -30, 30)) %>%
  distinct(PatientID)

# Keep only patients present in patient_dictionary
patients_no_shotgun <- patients_no_shotgun %>%
  filter(PatientID %in% patient_dictionary$cmicId)

# Join with patient_dictionary to get MRN
patients_with_mrn <- patients_no_shotgun %>%
  left_join(patient_dictionary, by = c("PatientID" = "cmicId"))

# Join with summary_data to get domination/infection status
patients_with_status <- patients_with_mrn %>%
  left_join(summary_data, by = "PatientID") %>%
  mutate(
    Priority = case_when(
      ever_dominated == TRUE | ever_infected == TRUE ~ "high",
      ever_dominated == FALSE & ever_infected == FALSE ~ "low",
      TRUE ~ "high"
    )
  )

# Select relevant columns: PatientID, MRN, Priority
result_table <- patients_with_status %>%
  select(PatientID, MRN, Priority)

# Write the result_table to CSV
write_csv(result_table, "document/tables/hct_patient_MRN.csv")
```

## Linking 16S ASVs to metagenome

I previously compiled the 16S sequences from the metagenomes while studying *Bacteroides* diveristy. Using the same Kraken results, I extracted the *Enterococcus* 16S sequences:

```{bash, eval=FALSE}
sbatch code/scripts/enterococcus_diversity/extract_enterococcus_16S.sh
```

Then I printed the *Enterococcus* 16S ASVs to a fasta:

```{r, eval=FALSE}
enterococcus_asvs <- read_csv("data/tblASVtaxonomy_silva132_v4v5_filter.csv") %>%
  filter(Genus == "Enterococcus") %>%
  select(ASV, Sequence)

# Save Bacteroides sequences in FASTA format
writeLines(
  paste0(">", enterococcus_asvs$ASV, "\n", enterococcus_asvs$Sequence),
  "analyses/enterococcus_diversity/16S/compiled/enterococcus_asvs.fasta"
)
```

After that, I did a BLASTn search of *Enterococcus* 16S ASVs against a database of the full length 16S extracted from the metagenomes:

```{bash, eval=FALSE}
sbatch code/scripts/enterococcus_diversity/blast_enterococcus_asvs_to_meta.sh
```

I also did a BLASTn search of the *Enterococcus* 16S sequences against the NCBI database:

```{bash, eval=FALSE}
sbatch code/scripts/enterococcus_diversity/blast_enterococcus_16S_ncbi.sh
```

The BLAST search only returned the NCBI TaxIDs of the hits, so I retrieved the correspoding species names:

```{bash, eval=FALSE}
# NCBI CLI
conda activate ncbi

# Input file with TaxIDs (one per line)
TAXID_FILE="analyses/enterococcus_diversity/16S/compiled/taxid_hits.txt"

# Output file for results
OUTPUT_FILE="analyses/enterococcus_diversity/16S/compiled/taxid_species.tsv"

# Get TaxIDs
cat analyses/enterococcus_diversity/16S/compiled/enterococcus_ncbi_blast.txt | tail -n +2 | cut -d $'\t'  -f 3 | sort | uniq > ${TAXID_FILE}

# Initialize the output file
> $OUTPUT_FILE

# Loop through each TaxID in the file
while read -r TAXID; do
    # Run the datasets command for the current TaxID
    datasets summary taxonomy taxon $TAXID | \
    grep -o '"species":{"id":[0-9]*,"name":"[^"]*"}' | \
    sed -E "s/.*\"id\":[0-9]+,\"name\":\"([^\"]+)\".*/${TAXID}\t\1/" >> $OUTPUT_FILE
done < $TAXID_FILE
```

```{r}
# Load the BLAST results and species ids
meta_to_ncbi_blast <- read_tsv("analyses/enterococcus_diversity/16S/compiled/enterococcus_ncbi_blast.txt")
asv_to_meta_blast <- read_tsv("analyses/enterococcus_diversity/16S/compiled/enterococcus_asv_to_meta_blast.txt", col_names = F)
colnames(asv_to_meta_blast) <- c("asv", "hit", "pident", "qlen", "slen", "alignment_length", "mismatches", "gaps")
taxid_species <- read_tsv("analyses/enterococcus_diversity/16S/compiled/taxid_species.tsv", col_names = F)

# Wrangle NCBI blast results to get IDs for the metagenomic 16S seqs
meta_to_ncbi_curated_blast <- meta_to_ncbi_blast %>%
  left_join(taxid_species, by = c("sscinames" = "X1")) %>%
  rename(species = X2) %>%
  group_by(qseqid) %>%
  slice_max(order_by = pident, with_ties = FALSE, n = 1) %>%
  ungroup() %>%
  mutate(method = str_extract(qseqid, "meta|targeted"))

# Add meta IDs to ASV blast results
asv_to_meta_map <- asv_to_meta_blast %>%
  left_join(select(meta_to_ncbi_curated_blast, qseqid, species, sacc, method), by = c(hit = "qseqid")) %>%
  group_by(asv) %>%
  slice_max(order_by = pident, with_ties = TRUE, n = 1)

asv_species_summary <- asv_to_meta_map %>%
  group_by(asv, mismatches) %>%
  summarise(
    n_species = n_distinct(species), # Count distinct species
    species = paste(unique(species), collapse = ", ") # Concatenate distinct species names
  ) %>%
  ungroup()
```

## *Enterococcus* genomic diversity

### MAG quality assesment and dereplication

 I compiled the *Enterococcus* MAGs binned as described in the [Exploring *Bacteroides* molecular variation]() section:

```{bash, eval=FALSE}
GTDB_FILE="analyses/yan_sd_2022/binning/gtdb/gtdbtk.bac120.summary.tsv"
BIN_DIR="analyses/yan_sd_2022/binning/compiled"
OUTPUT_DIR="analyses/enterococcus_diversity/genomes/mags"

# Create the output directory if it doesn't exist
mkdir -p ${OUTPUT_DIR}

# Extract filenames of bins classified in the family Enterococcaceae and copy them
awk -F'\t' 'NR > 1 && $2 ~ /f__Enterococcaceae/ {print $1}' "${GTDB_FILE}" | while read -r bin_file; do
  full_path="${BIN_DIR}/${bin_file}.fna"
  if [[ -f ${full_path} ]]; then
    cp "${full_path}" "${OUTPUT_DIR}/"
  else
    echo "File ${full_path} not found, skipping..."
  fi
done
```

And then I ran CheckM to assess genome quality:

```{bash, eval=FALSE}
sbatch code/scripts/enterococcus_diversity/enterococcus_checkm2.sh
```

I also calculated ANI between all genome pairs and dereplicated them at 98% ANI:

```{bash, eval=FALSE}
sbatch code/scripts/enterococcus_diversity/fastani.sh
sbatch code/scripts/enterococcus_diversity/drep_98.sh
```

### ST classification

I classified the MAGs into the STs scheme defined by [Homan et al. 2002](https://journals.asm.org/doi/10.1128/jcm.40.6.1963-1971.2002) using the `mlst` software:

```{bash, eval=FALSE}
sbatch code/scripts/enterococcus_diversity/mlst.sh
```

### Phylogeny with Lebreton et al 2013 reference

I compiled the genome assembly accessions from the [Lebreton et al 2013](https://journals.asm.org/doi/full/10.1128/mbio.00534-13) paper and downloaded them from NCBI:

```{bash, eval=FALSE}
# NCBI toolkit
conda activate ncbi

# Directory for NCBI genomes
LEBRETON_DIR="analyses/enterococcus_diversity/genomes/lebreton_2013"
mkdir -p ${LEBRETON_DIR}

# List of accessions from lebreton
cat data/lebreton_et_al_2013_genomes.csv | cut -d "," -f 12 | tail -n +2 > ${LEBRETON_DIR}/accessions.txt

# Download genomes from NCBI
datasets download genome accession --inputfile ${LEBRETON_DIR}/accessions.txt --dehydrated --filename ${LEBRETON_DIR}/genome.zip
unzip ${LEBRETON_DIR}/genome.zip -d ${LEBRETON_DIR}
datasets rehydrate --directory ${LEBRETON_DIR}
```

I compiled and renamed the genome files so they would correspond witht he assembly accession:

```{bash, eval=FLASE}
# Create directory for all .fna files
LEBRETON_FASTA_DIR_TMP="analyses/enterococcus_diversity/genomes/lebreton_2013/ncbi_dataset/tmp"
LEBRETON_FASTA_DIR="analyses/enterococcus_diversity/genomes/lebreton_2013/fasta"
mkdir -p ${LEBRETON_FASTA_DIR} ${LEBRETON_FASTA_DIR_TMP}

# Find and move all .fna files to the new directory
find ${LEBRETON_DIR}/ncbi_dataset/data/ -not -path "${LEBRETON_FASTA_DIR_TMP}/*" -type f -name "*.fna" -exec mv {} ${LEBRETON_FASTA_DIR_TMP} \;

# Copy and rename files
for file in ${LEBRETON_FASTA_DIR_TMP}/*; do
  base=$(basename "$file")
  new_name="${base%%.*}.fna"
  mv "$file" "$LEBRETON_FASTA_DIR/$new_name"
done
```

I selected a set 168 *E. facecium* MAGs which have >95% completeness and <5% contamination for the phylognetic analyses. I considered MAGs recovered with both the single and the multi binning strategies. When both strategies recovered a MAG from the same sample, I kept the one with the highest completeness value. I confirmed that there were no cases where I recovered two *E. facecium* MAGs from the sample.

```{r, eval=FALSE}
# Load required library and custom functions
suppressMessages(library(tidyverse))

# Load and merge GTBD results
meta_gtdb <- suppressMessages(read_tsv("analyses/yan_sd_2022/binning/gtdb/gtdbtk.bac120.summary.tsv"))

# Load CheckM2 results
checkm <- suppressMessages(read_tsv("analyses/enterococcus_diversity/genomes/checkm2/quality_report.tsv"))

# Compile E. faecium NC MAG data
efaecium_mag_data <- checkm %>%
  mutate(binning_strategy = case_when(
            str_detect(Name, "single") ~ "single",
            str_detect(Name, "multi") ~ "multi"
          ),
          sample = str_split(Name, "_", simplify = TRUE)[, 2]
        ) %>%
  left_join(meta_gtdb, by = c("Name" = "user_genome")) %>%
  mutate(species = str_remove(classification, ".*s__")) %>%
  filter(Completeness >= 95 & Contamination <= 5 & str_detect(species, "Enterococcus_B faecium")) %>%
  group_by(species, sample) %>%
    slice_max(order_by = Completeness, n = 1, with_ties = FALSE) %>%
    ungroup()

# Print list of paths to NC MAGs for pangenome analysis
write(paste0("analyses/enterococcus_diversity/genomes/mags/", efaecium_mag_data$genome, ".fna"), "analyses/enterococcus_diversity/genomes/efaecium_nc.txt")
```

I generated I file with the list of MAGs and reference genomes for the phylogeny:

```{bash, eval=FALSE}
# Paths
NC_MAGS="analyses/enterococcus_diversity/genomes/efaecium_nc.txt"
PHYLO_DIR="analyses/enterococcus_diversity/phylogenetics/mags_plus_lebreton"

# File with paths to Lebreton genomes
ls -d $LEBRETON_FASTA_DIR/*.fna > ${LEBRETON_DIR}/genome_paths.txt

# Driectory for phylogenetic analyses
mkdir -p ${PHYLO_DIR}

# List of genomes included in phylogenetic analyes
cat ${NC_MAGS} ${LEBRETON_DIR}/genome_paths.txt > ${PHYLO_DIR}/genome_list.txt
```

And then I ran ggCaller to get a core genome alignment and an NJ tree:

```{bash, eval=FALSE}
sbatch code/scripts/enterococcus_diversity/ggcaller_align.sh
```

## Timing of *Enterococcus* detection

### *Enterococcus* detection across metagenomic libraries

I tested the detection of the NC dereplicated MAGs of X *Enterococcus* species (*Enterococcus faecium*, *Enterococcus faecalis*, ) across all metagenomic libraries. I did this by mapping the reads from all samples to these MAGs. Then, a detection in a sample will be positive if there is >50% of the MAG covered by at least one read.

```{bash, eval=FALSE}
# Copy representative dereplicated NC MAGs
mkdir -p analyses/enterococcus_diversity/detection/ref_mags
cp analyses/enterococcus_diversity/genomes/drep/dereplicated_genomes/*.fna analyses/enterococcus_diversity/detection/ref_mags

# Run detection script
# Submit the first job and capture its job ID
jid=$(sbatch --array=1-1 code/scripts/enterococcus_diversity/enterococcus_detection.sh | awk '{print $4}') #8244928

# Submit the rest, dependent on the first finishing
sbatch --dependency=afterok:$jid --array=2-395%15 code/scripts/enterococcus_diversity/enterococcus_detection.sh #8246800
```

```{r, eval=FALSE}
# Load metagenomic detection results
meta_detection <- suppressMessages(read_tsv("analyses/enterococcus_diversity/detection/detection_results.tsv")) %>%
  left_join(select(enterococcus_mag_data, Name, species), by = c("mag" = "Name"))
```

### *Enterococcus* detection with 16S

```{r}
#
tblrel_genus_meta <- prep_taxa_counts("genus")

# Assign sample indices for each patient based on Timepoint
tblrel_genus_meta <- tblrel_genus_meta %>%
  group_by(PatientID) %>%
  arrange(Timepoint) %>%
  mutate(sample_index = row_number()) %>%
  ungroup()

# Identify the first sample where Enterococcus was detected for each patient
first_detection <- tblrel_genus_meta %>%
  filter(Enterococcus_abund > 0.001) %>%
  group_by(PatientID) %>%
  slice_min(order_by = sample_index, n = 1) %>%
  ungroup()

# Stratify by infection status
detection_summary <- first_detection %>%
  mutate(infection_status = ifelse(Enterococcus_infection, "Infected", "Not Infected")) %>%
  count(sample_index, infection_status, name = "num_patients")

# Create the bar plot
ggplot(detection_summary, aes(x = sample_index, y = num_patients, fill = infection_status)) +
  geom_bar(stat = "identity", position = "stack") +
  labs(
    x = "Sample index (ordered by Timepoint)",
    y = "Number of patients",
    fill = "E. faecium infection status"
  ) +
  scale_fill_manual(
    values = c("Infected" = "#0D7E2B", "Not Infected" = "gray75")
  ) +
  custom_theme
```

```{r, eval=FALSE}
tblrel_asv_meta <- prep_taxa_counts("asv")

asv_taxonomy <- read_csv("data/tblASVtaxonomy_silva132_v4v5_filter.csv")

# Merge ASV taxonomy with relative abundance data
tblrel_asv_meta <- tblrel_asv_meta %>%
  pivot_longer(cols = starts_with("ASV_"), names_to = "ASV", values_to = "abundance") %>%
  mutate(ASV = str_remove(ASV, "_abund")) %>%
  left_join(asv_taxonomy, by = "ASV")

# Filter for Enterococcus ASVs
enterococcus_asvs <- tblrel_asv_meta %>%
  filter(Genus == "Enterococcus")

# Identify the first sample for each patient
first_sample_asvs <- enterococcus_asvs %>%
  group_by(PatientID) %>%
  slice_min(order_by = Timepoint, n = 1) %>%
  ungroup() %>%
  select(PatientID, first_detected_asv = ASV)

# Identify the dominating ASV for each patient
dominating_asvs <- enterococcus_asvs %>%
  group_by(PatientID, ASV) %>%
  summarize(max_abundance = max(abundance, na.rm = TRUE), .groups = "drop") %>%
  filter(max_abundance > 0.3) %>%
  slice_max(order_by = max_abundance, n = 1, with_ties = FALSE) %>%
  select(PatientID, dominating_asv = ASV)

# Combine the results into a single table
result_table <- first_sample_asvs %>%
  left_join(dominating_asvs, by = "PatientID")

result_table
```

## Strain diversity and dynamics

### Metagenomic strain inference

I dereplicated all the MAGs recovered from the full metagenomes (both from single and multi strategies) at 98% ANI to generate a reference library to call variants for the strain analyses. I considered only MAGs with >50% completeness and <15% contamination:

```{bash, eval=FALSE}
sbatch code/scripts/enterococcus_diversity/drep_all_mags_98.sh
sbatch code/scripts/enterococcus_diversity/fastani_all_mags.sh
```

Then, I merged the dereplicated genomes into a single fasta to use as a library for competitive mapping in the strain analyses:

```{bash, eval=FALSE}
mkdir -p analyses/enterococcus_diversity/strains/ref_contigs
cat analyses/yan_sd_2022/binning/drep98/dereplicated_genomes/*.fna > analyses/enterococcus_diversity/strains/ref_contigs/ref_contigs.fna
```

Using the *E. faecium* genome `s_1044K_1_meta_vamb_single` annotated with Prokka (following nomenclature of [*E. faecium* strain DO](https://www.ncbi.nlm.nih.gov/nuccore/CP003583)), I ran both the inStrain pipeline for popANI and microdiversity calculations using the Prokka annotation following labeling :

```{bash, eval=FALSE}
# Get .gbk for E. faecium do to use as reference for Prokka annotation
conda activate ncbi
mkdir -p misc_files/entorococcus_diversity
efetch -db nucleotide -format gbwithparts -id CP003583 > misc_files/entorococcus_diversity/efaecium_DO.gbk

# Annotate E. faecium genomes with Prokka
sbatch code/scripts/enterococcus_diversity/prokka_efaecium_nc_mags.sh

# Extract contig names from the dereplicated E. faecium MAG fasta and save to a list
grep '^>' analyses/enterococcus_diversity/genomes/drep/dereplicated_genomes/s_1044K_1_meta_vamb_single.fna | sed 's/^>//' > analyses/enterococcus_diversity/strains/ref_contigs/ref_contig_list.txt

# Submit the first inStrain profile job (for the first sample) and capture its job ID
jid=$(sbatch --array=1-1 code/scripts/enterococcus_diversity/instrain_profile.sh | awk '{print $4}')

# Submit the rest of the inStrain profile jobs (samples 2-216), dependent on the first finishing, with a max of 15 concurrent jobs
sbatch --dependency=afterok:$jid --array=2-216%15 code/scripts/enterococcus_diversity/instrain_profile.sh

# Run inStrain compare to compare all inStrain profiles
sbatch code/scripts/enterococcus_diversity/instrain_compare.sh
```

and the floria pipeline for contig strain phasing:

```{bash, eval=FALSE}
jid=$(sbatch --array=1-1 code/scripts/enterococcus_diversity/floria_phasing.sh | awk '{print $4}')

sbatch --dependency=afterok:$jid --array=2-216%15 code/scripts/enterococcus_diversity/floria_phasing.sh
```

### Between-patient strain sharing

I wanted to visualize the relationship between strain sharing (popANI) and the time between stool sample collection from different patients to determine if strain sharing is more common when samples were taken closely in time. For this, I first needed to ggenerate a table of the time bewteen sample collection for the stool samples that were shotgun sequenced:

```{r}
# Load the sample metadata
meta_tblASVsamples <- suppressMessages(
  read_csv("data/tblASVsamples.csv",
    col_types = cols(
      .default = col_guess(),
      Pool = col_character()
    )) %>%
  filter(!is.na(AccessionShotgun)) %>%
  mutate(SampleID = paste0("s_", SampleID)) %>%
  distinct(AccessionShotgun, .keep_all = TRUE)
)

# Load the patient dictionary
patient_dictionary <- suppressMessages(
  read_csv("data/tCastoriPatientDictionaryWithDatesAndOtherStudiesPatientId.txt")
)

# Define column types for dictionary
patient_dictionary <- patient_dictionary %>%
  mutate(
    cmicId = as.character(cmicId),
    referenceDate = as.Date(referenceDate, format = "%Y-%m-%d")
  )

# Merge the sample metadata with the patient dictionary to get reference dates
meta_tblASVsamples_with_dates <- meta_tblASVsamples %>%
    left_join(patient_dictionary, by = c("PatientID" = "cmicId")) %>%
    mutate(
        collectionDate = referenceDate + days(Timepoint) # Convert patient-specific timepoints to actual dates
    )

# Generate all pairwise combinations of samples from different patients
time_difference <- meta_tblASVsamples_with_dates %>%
    select(SampleID, PatientID, collectionDate) %>%
    rename(sample1 = SampleID, patient1 = PatientID, date1 = collectionDate) %>%
    full_join(
        meta_tblASVsamples_with_dates %>%
            select(SampleID, PatientID, collectionDate) %>%
            rename(sample2 = SampleID, patient2 = PatientID, date2 = collectionDate),
        by = character()
    ) %>%
    #filter(patient1 != patient2) %>% # Keep only pairs from different patients
    mutate(
        # Ensure consistent ordering of sample1 and sample2
        #sample1 = if_else(sample1 < sample2, sample1, sample2),
        #sample2 = if_else(sample1 < sample2, sample2, sample1),
        time_between_sample_collection = abs(as.numeric(difftime(date1, date2, units = "days")))
    ) %>%
    #distinct(sample1, sample2, time_between_sample_collection, .keep_all = TRUE) %>% # Remove duplicate pairs
    select(sample1, sample2, time_between_sample_collection, patient1, patient2)

time_difference
```

Then, I was able to visualize the results from the inStrain comparisons in the context of the sample collection timeline:

```{r}
# Load inStrain comparison table
instrain_compare <- read_tsv("analyses/enterococcus_diversity/strains/instrain_compare/output/instrain_compare_genomeWide_compare.tsv") %>%
  mutate(sample1 = str_remove(name1, ".sorted.bam"),
        sample2 = str_remove(name2, ".sorted.bam"),
        popANI = popANI*100) %>%
  left_join(time_difference, by = c("sample1", "sample2")) %>%
  mutate(patient1_ord = if_else(patient1 < patient2, patient1, patient2),
        patient2_ord = if_else(patient1 < patient2, patient2, patient1)) %>%
  filter(percent_compared >= 0.85)

# Identify patients with NA values in instrain_compare
na_patients <- instrain_compare %>%
  filter(is.na(patient1) | is.na(patient2)) %>%
  select(sample1, sample2, patient1, patient2) %>%
  distinct()

# Comparisons between samples from the same patients
instrain_compare_within <- instrain_compare %>%
  filter(patient1_ord == patient2_ord) %>%
  mutate(log10_popANI = log10(100 - popANI))

# Comparisons between samples from different patients
instrain_compare_between <- instrain_compare %>%
  filter(patient1_ord != patient2_ord) %>%
  mutate(log10_popANI = log10(100 - popANI))

# Comparisons with the highest popANI for each pair of patients
instrain_compare_max_popANI <- instrain_compare_between %>%
  group_by(patient1_ord, patient2_ord) %>%
  slice_max(order_by = popANI, n = 1, with_ties = FALSE) %>%
  ungroup()

# Plot for all between-patient comparisons 
within_patient_pairs_plot <- ggplot(instrain_compare_within, aes(x = time_between_sample_collection, y = log10_popANI)) +
        geom_point(alpha = 0.6) +
        geom_hline(yintercept = log10(100 - 99.999), color = "red", linetype = "dashed") +
        scale_x_continuous(breaks = scales::pretty_breaks(n = 6)) +
        scale_y_continuous(
          breaks = log10(c(1, 0.1, 0.01, 0.001, 0.0001, 0.00001)),
          labels = c("99", "99.9", "99.99", "99.999", "99.9999", "99.99999"),
          trans = "reverse"
        ) +
        labs(
          x = "Time between sample collection (days)",
          y = "E. faecium popANI"
        ) +
        custom_theme

# Plot for all between-patient comparisons 
between_patient_pairs_plot <- ggplot(instrain_compare_between, aes(x = time_between_sample_collection, y = log10_popANI)) +
        geom_point(alpha = 0.6) +
        geom_hline(yintercept = log10(100 - 99.999), color = "red", linetype = "dashed") +
        scale_x_continuous(breaks = scales::pretty_breaks(n = 6)) +
        scale_y_continuous(
          breaks = log10(c(1, 0.1, 0.01, 0.001, 0.0001, 0.00001)),
          labels = c("99", "99.9", "99.99", "99.999", "99.9999", "99.99999"),
          trans = "reverse"
        ) +
        labs(
          x = "Time between sample collection (days)",
          y = "E. faecium popANI"
        ) +
        custom_theme

# Plot with the highest popANI for each pair of patients 
between_patient_max_plot <- ggplot(instrain_compare_max_popANI, aes(x = time_between_sample_collection, y = log10(100 - popANI))) +
          geom_point(alpha = 0.6) +
          geom_hline(yintercept = log10(100 - 99.999), color = "red", linetype = "dashed") +
          scale_x_continuous(breaks = scales::pretty_breaks(n = 6)) +
          scale_y_continuous(
            breaks = log10(c(1, 0.1, 0.01, 0.001, 0.0001, 0.00001)),
            labels = c("99", "99.9", "99.99", "99.999", "99.9999", "99.99999"),
            trans = "reverse"
          ) +
          labs(
            x = "Time between sample collection (days)",
            y = "max. E. faecium popANI between patients"
          ) +
          custom_theme

# Print the plots
within_patient_pairs_plot
between_patient_pairs_plot
between_patient_max_plot

# Save the plot
ggsave(between_patient_max_plot, filename = "document/plots/between_patient_max_popani.pdf", height = 4, width = 4)
```

These results indicate that there are only 10 pairs of patients of patients that share the same strain of *Enterococcus faecium* (i.e., popANI >99.999). I examined these 10 pairs:

```{r}
instrain_compare_max_popANI %>% filter(popANI >= 99.999) %>%
  select(sample1, sample2, patient1, patient2, popANI, conANI, time_between_sample_collection)
```

And it turns out that the 10 pairs correspond to 5 patients which all share the same strain:

```{r}
instrain_compare_max_popANI %>% 
  filter(popANI >= 99.999) %>%
  select(patient1, patient2, popANI) %>%
  pivot_wider(names_from = patient2, values_from = popANI, values_fill = NA, id_cols = patient1) %>%
  mutate(across(everything(), ~ coalesce(.x, NA))) %>%
  ungroup()
```

The dataset I analyzed includes a total of 18 patients:

```{r}
c(instrain_compare$patient1 %>% unique(), instrain_compare$patient2 %>% unique()) %>% unique()
```

### Within-patient strain diveristy and dynamics

I wanted to understand in greater detail why some within-patient comparisons seemed to not share strains, so I examined the data for each patient separately:

```{r}
# Patients with efacium
patients_meta <- c(instrain_compare$patient1 %>% unique(), instrain_compare$patient2 %>% unique()) %>% unique()

# Get the list of samples present in instrain_compare
samples_in_instrain <- unique(c(instrain_compare$sample1, instrain_compare$sample2))

# Filter meta_tblASVsamples to include only samples present in instrain_compare
meta_tblASVsamples_filtered <- meta_tblASVsamples %>%
  filter(SampleID %in% samples_in_instrain)

# Loop through each patient in patients_meta
popani_plots <- list()  # Store plots for each patient
for (patient in patients_meta) {

# Filter samples for the current patient
patient_samples <- meta_tblASVsamples_filtered %>%
    filter(PatientID == patient) %>%
    arrange(DayRelativeToNearestHCT) 

  # Initialize a data frame to store results
  patient_plot_data <- tibble(
    sample = character(),
    DayRelativeToNearestHCT = numeric(),
    popANI = numeric()
  )

  # Proceed only if there are at least 3 samples
  if (nrow(patient_samples) >= 3) {
    # Iterate through samples to calculate popANI with the previous sample
    for (i in 2:nrow(patient_samples)) {
      current_sample <- patient_samples$SampleID[i]
      previous_sample <- patient_samples$SampleID[i - 1]

      # Find the popANI between the current and previous samples
      popANI_value <- instrain_compare %>%
        filter(
          (sample1 == current_sample & sample2 == previous_sample) |
          (sample2 == current_sample & sample1 == previous_sample)
        ) %>%
        pull(popANI)

      # Add the result to the data frame
      if (length(popANI_value) > 0) {  # Ensure popANI exists for the pair
        patient_plot_data <- patient_plot_data %>%
          add_row(
            sample = current_sample,
            DayRelativeToNearestHCT = patient_samples$DayRelativeToNearestHCT[i],
            popANI = popANI_value
          )
      }
    }

    # Create the plot for the current patient
    p <- ggplot(patient_plot_data, aes(x = DayRelativeToNearestHCT, y = log10(100 - popANI))) +
      geom_point(alpha = 0.6) +
      geom_line(alpha = 0.6) +
      geom_hline(yintercept = log10(100 - 99.999), color = "red", linetype = "dashed") +
      scale_x_continuous(breaks = scales::pretty_breaks(n = 6)) +
      scale_y_continuous(
        limits = c(log10(100 - 99.900), log10(100 - 99.999994)),
        breaks = log10(c(1, 0.1, 0.01, 0.001, 0.0001, 0.00001)),
        labels = c("99", "99.9", "99.99", "99.999", "99.9999", "99.99999"),
        trans = "reverse"
      ) +
      labs(
        title = paste("Patient", patient),
        x = "Day Relative to Nearest HCT",
        y = "E. faecium popANI to previous sample"
      ) +
      custom_theme

    # Store the plot in the list
    popani_plots[[patient]] <- p
  }
}

# Print all plots
for (patient in names(popani_plots)) {
  print(popani_plots[[patient]])
}
```

## Pangenome dynamics

I selected a set 168 *E. facecium* MAGs which have >95% completeness and <5% contamination for the pangenome analyses. I considered MAGs recovered with both the single and the multi binning strategies. When both strategies recovered a MAG from the same sample, I kept the one with the highest completeness value. I confirmed that there were no cases where I recovered two *E. facecium* MAGs from the sample.

```{r, eval=FALSE}
# Load required library and custom functions
suppressMessages(library(tidyverse))

# Load and merge GTBD results
meta_gtdb <- suppressMessages(read_tsv("analyses/yan_sd_2022/binning/gtdb/gtdbtk.bac120.summary.tsv"))

# Load CheckM2 results
checkm <- suppressMessages(read_tsv("analyses/enterococcus_diversity/genomes/checkm2/quality_report.tsv"))

# Compile E. faecium NC MAG data
efaecium_mag_data <- checkm %>%
  mutate(binning_strategy = case_when(
            str_detect(Name, "single") ~ "single",
            str_detect(Name, "multi") ~ "multi"
          ),
          sample = str_split(Name, "_", simplify = TRUE)[, 2]
        ) %>%
  left_join(meta_gtdb, by = c("Name" = "user_genome")) %>%
  mutate(species = str_remove(classification, ".*s__")) %>%
  filter(Completeness >= 95 & Contamination <= 5 & str_detect(species, "Enterococcus_B faecium")) %>%
  group_by(species, sample) %>%
    slice_max(order_by = Completeness, n = 1, with_ties = FALSE) %>%
    ungroup()

# Print list of paths to NC MAGs for pangenome analysis
write(paste0("analyses/enterococcus_diversity/genomes/mags/", efaecium_mag_data$genome, ".fna"), "analyses/enterococcus_diversity/genomes/efaecium_nc.txt")
```

Then, I inferred the gene annotations and pnagenome for the 168 *E. faecium* MAGs using ggCaller:

```{bash, eval=FALSE}
sbatch code/scripts/enterococcus_diversity/ggcaller.sh #9392154
```

```{r}
pangenome <- read_tsv("analyses/enterococcus_diversity/pangenome/ggcaller/gene_presence_absence.Rtab")

# Load required libraries
suppressMessages(library(vegan))

# Filter pangenome data for the selected patients
selected_patients <- c("1252", "1203", "FMT.0069", "668", "FMT.0092")
genome_columns <- colnames(pangenome)[2:ncol(pangenome)]
selected_genomes <- genome_columns[grepl(paste(selected_patients, collapse = "|"), genome_columns) & 
                   !grepl("^s_668HH|^s_668LL|^s_668II|^668NN", genome_columns)]

# Subset the pangenome matrix for the selected genomes
pangenome_subset <- pangenome %>%
  select(Gene, all_of(selected_genomes)) %>%
  column_to_rownames("Gene") %>%
  as.matrix()

# Perform UMAP dimensionality reduction manually
# Calculate pairwise distances between genomes
distance_matrix <- dist(t(pangenome_subset))

# Initialize random coordinates for UMAP
set.seed(42)
n_genomes <- ncol(pangenome_subset)
umap_coords <- matrix(runif(n_genomes * 2, min = -1, max = 1), ncol = 2)

# Perform iterative optimization for UMAP
learning_rate <- 0.1
n_iterations <- 500
for (i in 1:n_iterations) {
  for (j in 1:n_genomes) {
    for (k in 1:n_genomes) {
      if (j != k) {
        # Compute attraction or repulsion based on distance
        dist_original <- as.matrix(distance_matrix)[j, k]
        dist_embedded <- sqrt(sum((umap_coords[j, ] - umap_coords[k, ])^2))
        gradient <- (dist_embedded - dist_original) * (umap_coords[j, ] - umap_coords[k, ]) / (dist_embedded + 1e-6)
        umap_coords[j, ] <- umap_coords[j, ] - learning_rate * gradient
      }
    }
  }
}

# Prepare data for plotting
umap_data <- as.data.frame(umap_coords)
colnames(umap_data) <- c("UMAP1", "UMAP2")
umap_data$Genome <- colnames(pangenome_subset)
umap_data$Patient <- sapply(umap_data$Genome, function(x) {
  patient <- selected_patients[sapply(selected_patients, function(p) grepl(p, x))]
  if (length(patient) > 0) patient[1] else NA
})

# Define distinct colors for the Patients
patient_colors <- c(
  "1252" = "#fed789",  # Light gray
  "1203" = "#5E4B3C",  # Brown
  "FMT.0069" = "#a4bed5",  # Taupe
  "668" = "#7b9941",  # Beige
  "FMT.0092" = "#476e84"  # Warm gray
)

# Plot the UMAP
ggplot(umap_data, aes(x = UMAP1, y = UMAP2, color = Patient)) +
  geom_point(size = 3, alpha = 0.9) +
  scale_color_manual(values = patient_colors) +
  labs(
    x = "UMAP Dimension 1",
    y = "UMAP Dimension 2",
    color = "Patient"
  ) +
  custom_theme

# Save the UMAP plot
ggsave("document/plots/pangenome_sharing_umap.pdf", width = 7, height = 7)
```

## Summary of genomic diversity for lab meeting

I first compiled the metadata for the E. faecium genomes that I worked with

```{r}
# Load and merge GTBD results
meta_gtdb <- suppressMessages(read_tsv("analyses/yan_sd_2022/binning/gtdb/gtdbtk.bac120.summary.tsv"))

# Load CheckM2 results
checkm <- suppressMessages(read_tsv("analyses/enterococcus_diversity/genomes/checkm2/quality_report.tsv"))

# Load MLST results
mlst_2002 <- read.csv("analyses/enterococcus_diversity/genomes/mlst/mlst_2002.csv", header = FALSE, fill = TRUE)
colnames(mlst_2002) <- c("genome_path",
                          "scheme",
                          "ST",
                          paste0("allele_", seq(1:7))
                          )
mlst_2002 <- mlst_2002 %>%
  mutate(genome = tools::file_path_sans_ext(basename(genome_path)))

# Compile MAG data
enterococcus_mag_data <- checkm %>%
  mutate(binning_strategy = case_when(
            str_detect(Name, "single") ~ "single",
            str_detect(Name, "multi") ~ "multi"
          ),
          sample = str_split(Name, "_", simplify = TRUE)[, 2]
        ) %>%
  left_join(meta_gtdb, by = c("Name" = "user_genome")) %>%
  left_join(mlst_2002, by = c("Name" = "genome")) %>%
  mutate(species = str_remove(classification, ".*s__")) %>%
  filter(Completeness >= 70 & Contamination <= 5 & str_detect(classification, "g__Enterococcus"))

# Load Lebreton metadata
lebreton_metadata <- suppressMessages(
  read_csv("data/lebreton_et_al_2013_genomes.csv") %>%
    mutate(tiplabel = str_remove(Accession, "\\.1"))
)
```

Then, I plotted different versions of the NJ tree to highlight:

1. Main clades and and distribution of hospital-associated *E. faecium

```{r}
# Load phylogenetics packages
suppressMessages(library(ape))
suppressMessages(library(ggtree))
suppressMessages(library(treeio))

# Load the NJ tree
lebreton_plus_mags_tree <- read.tree("analyses/enterococcus_diversity/phylogenetics/mags_plus_lebreton/ggcaller/core_tree_NJ.nwk")

# Remove single quotation marks from tip labels
lebreton_plus_mags_tree$tip.label <- gsub("'", "", lebreton_plus_mags_tree$tip.label)

# Root the tree with Clade B
outgroup <- lebreton_metadata %>% filter(Clade == "B") %>% pull(tiplabel)
lebreton_plus_mags_tree <- root(lebreton_plus_mags_tree, outgroup = outgroup, resolve.root = TRUE)

# MAG source metadata
mag_source_data <- enterococcus_mag_data %>%
  filter(Name %in% lebreton_plus_mags_tree$tip.label) %>%
  mutate(tiplabel = Name,
    source = "MSK") %>%
  select(tiplabel, source)

# Lebreton source metadata
hospital_categories <- c("Hosp_Feces", "Clinical Isolate", "Hospital Surveillance", "Hospital Outbreak", "Hospital Unknown")
lebreton_source_data <- lebreton_metadata %>%
  mutate(source = case_when(Category %in% hospital_categories ~ "Hospital",
                            Category == "Non-hospitalized individual" ~ "Human commensal",
                            .default = Category)) %>%
  select(tiplabel, source)

# Compile source metadata
source_data <- bind_rows(mag_source_data, lebreton_source_data)

clade_a1_node <- MRCA(lebreton_plus_mags_tree, c("GCF_000322425", "GCF_000239095"))

# Merge tree tip labels with source data
tree_data_main <- as_tibble(lebreton_plus_mags_tree) %>%
  left_join(source_data, by = c("label" = "tiplabel"))

# Define colors and shapes for sources
source_colors <- c(
  "MSK" = "#f4a261",          # Warm orange
  "Hospital" = "#e63946",     # Deep red
  "Human commensal" = "#2a9d8f", # Teal green
  "Animal" = "#89c2d9",       # Light blue
  "Other" = "gray50"          # Neutral gray
)
source_shapes <- c("MSK" = 16, "Hospital" = 16, "Human commensal" = 16, "Animal" = 16, "Other" = 16)

# Plot the tree with tip shapes and colors
ggtree(lebreton_plus_mags_tree, layout = "circular") %<+% tree_data_main +
  geom_tippoint(aes(color = source, shape = source), size = 3) +
  scale_color_manual(values = source_colors) +
  scale_shape_manual(values = source_shapes) +
  geom_hilight(node = clade_a1_node, fill = "gray75", alpha = 0.4, to.bottom = T) +
  geom_cladelab(node = clade_a1_node, label = "A1", barsize = 0, fontsize = 8, offset.text = 6000) +
  geom_strip(taxa1 = "GCF_000322285", taxa2 = "GCF_000321765",
              barsize = 2,
              label = "A2",
              offset = 1000,
              offset.text = 3000,
              fontsize = 8) +
  geom_strip(taxa1 = "GCF_000157655", taxa2 = "GCF_000322145",
              barsize = 2,
              label = "B",
              offset = 4000,
              offset.text = 3000,
              fontsize = 8,
              align = F) +
  theme(legend.position = "right")

# Save the plot
#ggsave("document/plots/lebreton_plus_mags_main.pdf")
```

2. Clade A1 highlighting the STs:

```{r}
# Clade A1 taxa
clade_a1_tips <- c(filter(lebreton_metadata, Clade == "A1") %>% pull(tiplabel), pull(mag_source_data, tiplabel))

# Prune the tree to keep only clade A1 tips
clade_a1_tree <- keep.tip(lebreton_plus_mags_tree, clade_a1_tips)

# ST data for taxa in Clade A1
st_data <- source_data %>%
  left_join(select(enterococcus_mag_data, Name, ST), by = c("tiplabel" = "Name"))

# Join tree with data
tree_data_st <- as_tibble(clade_a1_tree) %>%
  left_join(st_data, by = c("label" = "tiplabel"))

# Plot the tree with tip labels colored by ST to check 
ggtree(clade_a1_tree, layout = "rectangular") %<+% tree_data_st +
  geom_tiplab() +
  geom_tippoint(aes(color = ST), size = 3) +
  labs(color = "ST") +
  theme(legend.position = "right")

# 
st_a1_tree_plot <- ggtree(clade_a1_tree, layout = "rectangular") %<+% tree_data_st +
  geom_tippoint(aes(color = source, shape = source), size = 3) +
  scale_color_manual(values = source_colors) +
  scale_shape_manual(values = source_shapes) +
  geom_strip(taxa1 = "GCF_000322345", taxa2 = "s_1203K_33_meta_vamb_multi",
              barsize = 2,
              label = "ST 412",
              offset = 50,
              offset.text = 80,
              fontsize = 6,
              align = F) +
  geom_strip(taxa1 = "s_1042W_5_meta_vamb_single", taxa2 = "s_1179D_3_meta_vamb_single",
              barsize = 2,
              label = "ST 18",
              offset = 300,
              offset.text = 80,
              fontsize = 6,
              align = F) +
  geom_strip(taxa1 = "s_FMT.0035K_19_meta_vamb_multi", taxa2 = "s_1179V_1_meta_vamb_single",
              barsize = 2,
              label = "ST 736",
              offset = 80,
              offset.text = 80,
              fontsize = 6,
              align = F) +
  geom_strip(taxa1 = "s_1044L_1_meta_vamb_single", taxa2 = "s_1044O_1_meta_vamb_single",
              barsize = 2,
              label = "ST 789",
              offset = 60,
              offset.text = 80,
              fontsize = 6,
              align = F) +
  geom_strip(taxa1 = "s_2142J_13_meta_vamb_multi", taxa2 = "s_2142K_1_meta_vamb_single",
              barsize = 2,
              label = "ST 80",
              offset = 60,
              offset.text = 80,
              fontsize = 6,
              align = F) +
  geom_strip(taxa1 = "s_FMT.0064X_16805_meta_vamb_single", taxa2 = "s_668II_59_meta_vamb_multi",
              barsize = 2,
              label = "ST 1421",
              offset = 60,
              offset.text = 80,
              fontsize = 6,
              align = F) +
  theme(legend.position = "none")

# Save the plot
ggsave(st_a1_tree_plot, filename = "document/plots/lebreton_plus_mags_st.pdf")
```

3. Focus on sinlge-strain patient 1105:

```{r}
# Find node for patient 1105 MAGs
node_1105 <- MRCA(clade_a1_tree, c("s_1105F_34_meta_vamb_multi", "s_1105S_34_meta_vamb_multi"))

# Plot the ST tree highlighting samples from patient 1105
st_a1_tree_plot +
  geom_hilight(node = node_1105, fill = "#8719e0", alpha = 0.2, to.bottom = T)

# Save the plot
ggsave("document/plots/lebreton_plus_mags_1105.pdf")
```

4. Focus on multi-strain replacement patient 1179:

```{r}
# Find nodes for patient 1179
node_1179_18 <- MRCA(clade_a1_tree, c("s_1179B_4_meta_vamb_single", "s_1179D_3_meta_vamb_single"))
node_1179_736 <- MRCA(clade_a1_tree, c("s_1179W_2_meta_vamb_single", "s_1179V_1_meta_vamb_single"))

# Plot tree higlighting 1179 samples
st_a1_tree_plot +
  geom_hilight(node = node_1179_736, fill = "#8719e0", alpha = 0.2, to.bottom = F) +
  geom_hilight(node = node_1179_18, fill = "#8719e0", alpha = 0.2, to.bottom = F)

# Save the plot
ggsave("document/plots/lebreton_plus_mags_1179.pdf", width = 6)
```

5. Focus on multi-strain coexistence in patient 1044:

```{r}
# Find nodes for patient 1179
node_1044_80 <- MRCA(clade_a1_tree, c("s_1044L_1_meta_vamb_single", "s_1044Q_27_meta_vamb_multi"))
node_1044_N <- MRCA(clade_a1_tree, c("s_1044J_27_meta_vamb_multi", "s_1044E_27_meta_vamb_multi"))

# Plot tree higlighting 1179 samples
st_a1_tree_plot +
  geom_hilight(node = node_1044_80, fill = "#8719e0", alpha = 0.2, to.bottom = T) +
  geom_hilight(node = node_1044_N, fill = "#8719e0", alpha = 0.2, to.bottom = T)

# Save the plot
ggsave("document/plots/lebreton_plus_mags_1044.pdf", width = 6)
```

5. Focus ST 42 shared by five patients:

```{r}
node_412_share <- MRCA(clade_a1_tree, c("s_1252CCC_74_meta_vamb_multi", "s_FMT.0092X_45_meta_vamb_multi"))

# Plot tree higlighting ST 412 samples
st_a1_tree_plot +
  geom_hilight(node = node_412_share, fill = "#8719e0", alpha = 0.2, to.bottom = T)
# Save the plot
ggsave("document/plots/lebreton_plus_mags_412_share.pdf", width = 6)
```

```{r}
# Load patient metadata and drug info
suppressMessages({
  tblrel_asv_meta <- prep_taxa_counts("asv")
  tblhctmeta <- read_csv("data/tblhctmeta.csv")
  tbldrug <- read_csv("data/tbldrug.csv")
})

# Plot patient ASV timelines
plot_patient_timeline_asv("1179", tblrel_asv_meta)
ggsave("document/plots/asv_timeline_1179.pdf", height = 4)
plot_patient_timeline_asv("1044", tblrel_asv_meta) +
  scale_x_continuous(breaks = scales::pretty_breaks(n = 5))
ggsave("document/plots/asv_timeline_1044.pdf", height = 4)

# Plot patient Drug timelines
plot_patient_drug_timeline("1179", tbldrug, tblhctmeta, tblrel_asv_meta)
ggsave("document/plots/drug_timeline_1179.pdf", height = 2.5)
plot_patient_drug_timeline("1044", tbldrug, tblhctmeta, tblrel_asv_meta) +
      scale_x_continuous(limits = c(-7, 18),
                      breaks = scales::pretty_breaks(n = 5))
ggsave("document/plots/drug_timeline_1044.pdf", height = 2.5)

# Plot and save popANI timelines
popani_plots[["1179"]]
ggsave("document/plots/popani_timeline_1179.pdf", height = 3)
popani_plots[["1044"]] +
      scale_x_continuous(limits = c(-7, 18),
                      breaks = scales::pretty_breaks(n = 5))
ggsave("document/plots/popani_timeline_1044.pdf", height = 3)
```

## Trash
```{r, eval=FALSE}
# Load FastANI results
fastani <- read_tsv("analyses/enterococcus_diversity/genomes/fastani/fastani_results.tsv", col_names = FALSE)
colnames(fastani) <- c("genome1", "genome2", "ANI", "aligned_fragments", "total_fragments")
fastani <- fastani %>% 
  mutate(alignment_fraction = aligned_fragments/total_fragments,
        genome1 =  tools::file_path_sans_ext(basename(genome1)),
        genome2 =  tools::file_path_sans_ext(basename(genome2)))

        # Filter genomes for Enterococcus_B faecium
        faecium_genomes <- enterococcus_mag_data %>%
          filter(species == "Enterococcus_B faecium" & binning_strategy == "multi") %>%
          pull(Name)

        # Subset FastANI results for these genomes
        faecium_fastani <- fastani %>%
          filter(genome1 %in% faecium_genomes & genome2 %in% faecium_genomes) %>%
          select(genome1, genome2, ANI)

        # Convert ANI to a distance matrix
        faecium_dist_matrix <- faecium_fastani %>%
          pivot_wider(names_from = genome2, values_from = ANI, values_fill = 0) %>%
          column_to_rownames("genome1") %>%
          as.matrix()

        # Convert ANI to distance (1 - ANI/100)
        faecium_dist_matrix <- 100 - faecium_dist_matrix

        # Create a phylogenetic tree using hierarchical clustering with the average method
        faecium_hclust <- hclust(as.dist(faecium_dist_matrix), method = "complete")
        diag(faecium_dist_matrix) <- 0

        # Map ST values to genome names and assign colors
        st_colors <- enterococcus_mag_data %>%
          filter(Name %in% faecium_genomes) %>%
          select(Name, ST) %>%
          mutate(ST = factor(ST)) %>%
          mutate(color = scales::hue_pal()(nlevels(ST))[as.numeric(ST)]) %>%
          select(Name, color) %>%
          deframe()

        # Convert hclust object to a phylogenetic tree
        faecium_hclust_tree <- as.phylo(faecium_hclust)

        # Plot the tree with base R and color tip labels by ST
        plot(faecium_hclust_tree, tip.color = st_colors, cex = 0.8)
```