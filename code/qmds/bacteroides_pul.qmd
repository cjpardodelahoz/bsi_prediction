---
title: "Using PULs to predict Proteobacteria BSI risk"
engine: knitr
format:
  html:
    code-fold: true
    code-summary: "Show the code"
---

## Quantifying PUL abundance at metagenome scale

I started with the metagenomic assemblies that I generated for the Enterococcus F32 exploration. They are under `analyses/enterococcus_diversity/metagenomes/assembly/metaspades/`, but I will symlink them to a new directory to simplify paths:

```{bash, eval=FALSE}
mkdir -p analyses/bacteroides_pul/metagenomes/assembly
ln -s /data1/xavierj/carlos/bsi_prediction/analyses/enterococcus_diversity/metagenomes/assembly/metaspades /data1/xavierj/carlos/bsi_prediction/analyses/bacteroides_pul/metagenomes/assembly/metaspades
```

Some of the reads failed to assembly due to memory requirements, so I took the assemblies available from Isabl for those samples:

```{bash, eval=FALSE}
# Print list of samples missing assemblies
while read sample; do
  if [ ! -f "analyses/bacteroides_pul/metagenomes/assembly/metaspades/${sample}/contigs.fasta" ]; then
    echo "$sample"
  fi
done < misc_files/bacteroides_pul/isabl1_samples.txt > misc_files/bacteroides_pul/missing_assemblies.txt

# Activate isabl conda
conda activate /usersoftware/collab004/conda/isablprod

# Set env variables
export ISABL_CLIENT_ID=1
export ISABL_API_URL="https://isabl.microbiome.mskcc.org/api/v1"

# Load sample names to variable
TARGET_SAMPLES=$(paste -sd, misc_files/bacteroides_pul/missing_assemblies.txt)

# Get the assembly paths available from isabl
isabl get-metadata analyses \
    -fi application.pk 84 \
    -fi targets.sample.identifier.in ${TARGET_SAMPLES} \
    --field targets.sample.identifier \
    --field results.assembly_fa | grep "fasta" >  misc_files/bacteroides_pul/missing_assembly_paths.txt

while IFS=$'\t' read -r sample path; do
  # Remove brackets and single quotes from sample name
  sample_clean=$(echo "$sample" | sed "s/\[\('\([^']*\)'\)\]/\2/")
  # Fix origin path if needed
  path_fixed=$(echo "$path" | sed 's|/data/brinkvd/|/data1/collab004/|')
  # Make destination directory if it doesn't exist
  dest_dir="analyses/bacteroides_pul/metagenomes/assembly/metaspades/${sample_clean}"
  mkdir -p "$dest_dir"
  # Copy fasta file
  cp "$path_fixed" "${dest_dir}/contigs.fasta"
done < misc_files/bacteroides_pul/missing_assembly_paths.txt

# Print list of samples with succesful assemblies
while read sample; do
  if [ -f "analyses/bacteroides_pul/metagenomes/assembly/metaspades/${sample}/contigs.fasta" ]; then
    echo "$sample"
  fi
done < misc_files/bacteroides_pul/isabl1_samples.txt > misc_files/bacteroides_pul/isabl1_succesful_assemblies.txt
```

Let's rerun the contig filtering to ensure that all assemblies contain only contigs >= 1000 bps:

```{bash, eval=FALSE}
sbatch code/scripts/bacteroides_pul/filter_contigs_isabl1.sh
```

Then I obtained CGCs and PUL predictions with DBCAN:

```{bash, eval=FALSE}
sbatch code/scripts/bacteroides_pul/dbcan_isabl1.sh #6223852
```

These failed because there were no CGCs found: 2035, 1880, 1655, 1640, 1530, 1063, 63, 40.

Having the predictions, I ran the pipeline to obtain TPM counts of the CGCs and PULs:

```{bash, eval=FALSE}
sbatch code/scripts/bacteroides_pul/get_pulabund.sh
```

Finally, we compile the quantification results into feature tables at different levels for the samples for which the run was successful:

```{bash, eval=FALSE}
# Make directory for modeling
mkdir -p analyses/bacteroides_pul/pul_modeling/feature_tables

# Exclude the samples for which the PUL predition did not work
awk 'NR!=2035 && NR!=1880 && NR!=1655 && NR!=1640 && NR!=1530 && NR!=1063 && NR!=63 && NR!=40' \
  misc_files/bacteroides_pul/isabl1_succesful_assemblies.txt > analyses/bacteroides_pul/pul_modeling/isabl1_succesful_pulpredictions.txt

# Get feature tables
for out_type in fam_substrate fam subfam PUL EC; do
  python software/custom/get_pulfeatures.py \
    --samples misc_files/bacteroides_pul/isabl1_succesful_pulpredictions.txt \
    --output analyses/bacteroides_pul/pul_modeling/feature_tables/${out_type}.tsv \
    --base_dir analyses/bacteroides_pul/pul_prediction/abund/ \
    --output_type ${out_type}
done
```


## Modeling Pseudomonadota BSI and expansion with PUL scores in allo-HCT patients

### Defining BSI case and control sets from metagenomic samples

Let's figure which patients have metagenomic samples within a certain period (7, 14, and 30 days) before a proteobacteria BSI:

```{r}
# Load required libraries and functions
suppressMessages(library(tidyverse))
source("code/rfunctions/data_helpers.r")

# Load the list of isabl1 samples with PUL predictions
pul_samples <- scan("analyses/bacteroides_pul/pul_modeling/isabl1_succesful_pulpredictions.txt", what = "character")

# Load the table with sample-patient data
tblASVsamples <- read_csv("data/tblASVsamples.csv") %>%
  distinct(SampleID, .keep_all = TRUE) %>%
  mutate(isabl1 = SampleID %in% pul_samples) %>%
  select(SampleID, PatientID, DayRelativeToNearestHCT, isabl1)

# Load the patientday table
load("analyses/processed_data/tblpatientday_clinical.RData")
tblpatientday_clinical$DayRelativeToNearestHCT <- as.numeric(as.character(tblpatientday_clinical$DayRelativeToNearestHCT))

# Annorate patientday table with isabl1
tblpatientday_isabl1 <- tblpatientday_clinical %>%
  left_join(tblASVsamples, by = c("PatientID" = "PatientID", "DayRelativeToNearestHCT" = "DayRelativeToNearestHCT"))

# Patients with at least one metagenome and a Proteobacteria infection
proteobsi_isabl1_all <- tblpatientday_isabl1 %>%
  group_by(PatientID) %>%
  summarize(
    has_isabl1 = any(isabl1 == TRUE, na.rm = TRUE),
    has_proteo = any(Proteobacteria_infection == 1, na.rm = TRUE)
  ) %>%
  filter(has_isabl1 & has_proteo) %>%
  pull(PatientID) %>%
  sort() %>%
  unique()

# Let's now find the patients with metagenomes within X days of the first Proteo infection

# Find first day of Proteobacteria_infection for each patient
first_proteo <- tblpatientday_isabl1 %>%
  filter(Proteobacteria_infection == 1) %>%
  group_by(PatientID) %>%
  summarize(first_infection_day = min(DayRelativeToNearestHCT, na.rm = TRUE))

# Patients with a metagenome within 7 days before or on the first infection day
proteobsi_isabl1_7day <- tblpatientday_isabl1 %>%
  inner_join(first_proteo, by = "PatientID") %>%
  filter(isabl1 == TRUE,
         DayRelativeToNearestHCT >= (first_infection_day - 7),
         DayRelativeToNearestHCT <= first_infection_day) %>%
  pull(PatientID) %>%
  unique() %>%
  sort()

# Patients with a metagenome within 14 days before or on the first infection day
proteobsi_isabl1_14day <- tblpatientday_isabl1 %>%
  inner_join(first_proteo, by = "PatientID") %>%
  filter(isabl1 == TRUE,
         DayRelativeToNearestHCT >= (first_infection_day - 14),
         DayRelativeToNearestHCT <= first_infection_day) %>%
  pull(PatientID) %>%
  unique() %>%
  sort()

# Patients with a metagenome within 14 days before or on the first infection day
proteobsi_isabl1_20day <- tblpatientday_isabl1 %>%
  inner_join(first_proteo, by = "PatientID") %>%
  filter(isabl1 == TRUE,
         DayRelativeToNearestHCT >= (first_infection_day - 20),
         DayRelativeToNearestHCT <= first_infection_day) %>%
  pull(PatientID) %>%
  unique() %>%
  sort()

# Show patient lists
proteobsi_isabl1_7day
proteobsi_isabl1_14day
proteobsi_isabl1_20day
```

Now, for each set, let's make a matching control set for the statistical analyses:

```{r}
casecontrol_7day <- create_case_control_data(n_controls = 4, proteobsi_isabl1_7day) %>% distinct(PatientID, .keep_all = TRUE)
casecontrol_14day <- create_case_control_data(n_controls = 4, proteobsi_isabl1_14day) %>% distinct(PatientID, .keep_all = TRUE)
casecontrol_20day <- create_case_control_data(n_controls = 4, proteobsi_isabl1_20day) %>% distinct(PatientID, .keep_all = TRUE)
```

Let's print the Patient IDs from the matched case-control datasets to send to Isaac for benchmarking:

```{r}
if (!dir.exists("analyses/bacteroides_pul/pul_modeling/casecontrol_sets")) {
  dir.create("analyses/bacteroides_pul/pul_modeling/casecontrol_sets", recursive = TRUE, showWarnings = FALSE)
}
casecontrol_7day_patients <- casecontrol_7day$PatientID
casecontrol_14day_patients <- casecontrol_14day$PatientID
casecontrol_20day_patients <- casecontrol_20day$PatientID
writeLines(casecontrol_7day_patients, "analyses/bacteroides_pul/pul_modeling/casecontrol_sets/casecontrol_7day_patients.txt")
writeLines(casecontrol_14day_patients, "analyses/bacteroides_pul/pul_modeling/casecontrol_sets/casecontrol_14day_patients.txt")
writeLines(casecontrol_20day_patients, "analyses/bacteroides_pul/pul_modeling/casecontrol_sets/casecontrol_20day_patients.txt")
```

### Defining PUL features that predict Pseudomonadota BSI and expansion

We used the 16S-based relative abundance of *Bacteroides* as a point of comparison for the predictive power of the PUL features. Thus, I first needed to compile those data. I prepared a version of the dataset where I merged the relative abundances of ASVs in three groups:

  - *Bacteroides s. lat*: all ASVs classified as *Bacteroides* in the original dataset, which includes both *Bacteroides* and *Phocaeicola* species.
  - *Bacteroides s. str.*: All ASVs classified as *Bacteroides* after removing the ones that matched full 16S sequences of *Phocaeicola*.
  - *Phocaeicola*: All ASVs that matched full 16S sequences of *Phocaeicola*, plus ASV_6242, which was the only one originally classified as *Phocaeicola*.

```{r}
# Load the species summary
load("analyses/processed_data/asv_species_summary.RData")

# Define the ASVs in each group_by
bacteroides_slat_asvs <- asv_species_summary %>%
  pull(asv)
bacteroides_sstr_asvs <- asv_species_summary %>%
  filter(!str_detect(species, "Phocaeicola") & mismatches <= 1) %>%
  pull(asv)
phocaeicola_asvs <- c(
  asv_species_summary %>%
    filter(str_detect(species, "Phocaeicola") & mismatches <= 1) %>%
    pull(asv), 
  "ASV_6242")

# Get the 16S features and group the ASVs
#tblrel_genus_meta <- prep_taxa_counts("genus")
tblrel_asv_meta <- prep_taxa_counts("asv") %>%
  mutate(
    Bacteroides_s_lat = {
      cols <- intersect(paste0(bacteroides_slat_asvs, "_abund"), names(.))
      if (length(cols) > 0) rowSums(select(., all_of(cols)), na.rm = TRUE) else 0
    },
    Bacteroides_s_str = {
      cols <- intersect(paste0(bacteroides_sstr_asvs, "_abund"), names(.))
      if (length(cols) > 0) rowSums(select(., all_of(cols)), na.rm = TRUE) else 0
    },
    Phocaeicola = {
      cols <- intersect(paste0(phocaeicola_asvs, "_abund"), names(.))
      if (length(cols) > 0) rowSums(select(., all_of(cols)), na.rm = TRUE) else 0
    }
  ) %>%
  select(Sample, Bacteroides_s_lat, Bacteroides_s_str, Phocaeicola, ASV_277_abund, ASV_94_abund, ASV_223_abund, ASV_1875_abund)
```

Now we can add the PUL and 16S features to the case-control datasets:

```{r}
# Load the PUL feature tables
fam <- read_delim("analyses/bacteroides_pul/pul_modeling/feature_tables/fam.tsv")
fam_substrate <- read_delim("analyses/bacteroides_pul/pul_modeling/feature_tables/fam_substrate.tsv")
subfam <- read_delim("analyses/bacteroides_pul/pul_modeling/feature_tables/subfam.tsv")
pul <- read_delim("analyses/bacteroides_pul/pul_modeling/feature_tables/pul.tsv")
ec <- read_delim("analyses/bacteroides_pul/pul_modeling/feature_tables/ec.tsv")

# Add features to Case-control sets
casecontrol_fam_7day <- casecontrol_7day %>% 
  left_join(fam, by = c("SampleID" = "sample")) %>%
  left_join(tblrel_asv_meta, by = c("SampleID" = "Sample"))
casecontrol_fam_substrate_7day <- casecontrol_7day %>%
  left_join(fam_substrate, by = c("SampleID" = "sample")) %>%
  left_join(tblrel_asv_meta, by = c("SampleID" = "Sample"))
casecontrol_subfam_7day <- casecontrol_7day %>%
  left_join(subfam, by = c("SampleID" = "sample")) %>%
  left_join(tblrel_asv_meta, by = c("SampleID" = "Sample"))
casecontrol_pul_7day <- casecontrol_7day %>%
  left_join(pul, by = c("SampleID" = "sample")) %>%
  left_join(tblrel_asv_meta, by = c("SampleID" = "Sample"))
casecontrol_ec_7day <- casecontrol_7day %>%
  left_join(ec, by = c("SampleID" = "sample")) %>%
  left_join(tblrel_asv_meta, by = c("SampleID" = "Sample"))

casecontrol_fam_14day <- casecontrol_14day %>%
  left_join(fam, by = c("SampleID" = "sample")) %>%
  left_join(tblrel_asv_meta, by = c("SampleID" = "Sample"))
casecontrol_fam_substrate_14day <- casecontrol_14day %>%
  left_join(fam_substrate, by = c("SampleID" = "sample")) %>%
  left_join(tblrel_asv_meta, by = c("SampleID" = "Sample"))
casecontrol_subfam_14day <- casecontrol_14day %>%
  left_join(subfam, by = c("SampleID" = "sample")) %>%
  left_join(tblrel_asv_meta, by = c("SampleID" = "Sample"))
casecontrol_pul_14day <- casecontrol_14day %>%
  left_join(pul, by = c("SampleID" = "sample")) %>%
  left_join(tblrel_asv_meta, by = c("SampleID" = "Sample"))
casecontrol_ec_14day <- casecontrol_14day %>%
  left_join(ec, by = c("SampleID" = "sample")) %>%
  left_join(tblrel_asv_meta, by = c("SampleID" = "Sample"))

casecontrol_fam_20day <- casecontrol_20day %>%
  left_join(fam, by = c("SampleID" = "sample")) %>%
  left_join(tblrel_asv_meta, by = c("SampleID" = "Sample"))
casecontrol_fam_substrate_20day <- casecontrol_20day %>%
  left_join(fam_substrate, by = c("SampleID" = "sample")) %>%
  left_join(tblrel_asv_meta, by = c("SampleID" = "Sample"))
casecontrol_subfam_20day <- casecontrol_20day %>%
  left_join(subfam, by = c("SampleID" = "sample")) %>%
  left_join(tblrel_asv_meta, by = c("SampleID" = "Sample"))
casecontrol_pul_20day <- casecontrol_20day %>%
  left_join(pul, by = c("SampleID" = "sample")) %>%
  left_join(tblrel_asv_meta, by = c("SampleID" = "Sample"))
casecontrol_ec_20day <- casecontrol_20day %>%
  left_join(ec, by = c("SampleID" = "sample")) %>%
  left_join(tblrel_asv_meta, by = c("SampleID" = "Sample"))
```


```{r}

datasets <- list(
  "7day" = casecontrol_fam_7day,
  "14day" = casecontrol_fam_14day,
  "20day" = casecontrol_fam_20day
)
covariates <- c("Bacteroides_s_lat", "Bacteroides_s_str", "Phocaeicola", "ASV_277_abund", "ASV_94_abund", "ASV_223_abund", "ASV_1875_abund")

test_covariate <- function(df, covar, test = c("both", "regression", "wilcox")) {
  test <- match.arg(test)
  # Keep rows with non-missing case and covariate for either test
  df <- df %>% filter(!is.na(case), !is.na(.data[[covar]]))
  
  # Prepare default empty results
  default_reg <- tibble(term = covar, estimate = NA_real_, std.error = NA_real_, statistic = NA_real_, p.value = NA_real_, variable = covar)
  default_wilcox <- tibble(variable = covar, statistic = NA_real_, p.value = NA_real_)
  
  # Run regression if requested
  if (test %in% c("both", "regression")) {
    form <- as.formula(paste("case ~", covar))
    reg <- tryCatch(glm(form, data = df, family = binomial), error = function(e) NULL)
    reg_tidy <- if (!is.null(reg)) {
      broom::tidy(reg) %>% filter(term == covar) %>% mutate(variable = covar)
    } else {
      default_reg
    }
  } else {
    reg_tidy <- default_reg
  }
  
  # Run wilcox if requested
  if (test %in% c("both", "wilcox")) {
    wilcox <- tryCatch(wilcox.test(formula = as.formula(paste(covar, "~ case")), data = df), error = function(e) NULL)
    wilcox_tbl <- if (!is.null(wilcox)) {
      tibble(variable = covar, statistic = wilcox$statistic, p.value = wilcox$p.value)
    } else {
      default_wilcox
    }
  } else {
    wilcox_tbl <- default_wilcox
  }
  
  list(
    regression = reg_tidy,
    wilcox = wilcox_tbl
  )
}

# Regression results
regression_results <- bind_rows(
  lapply(names(datasets), function(day) {
    map_dfr(covariates, function(covar) {
      test_covariate(datasets[[day]], covar, test = "regression")$regression %>%
        mutate(dataset = day)
    })
  })
)

# Wilcox results
wilcox_results <- bind_rows(
  lapply(names(datasets), function(day) {
    map_dfr(covariates, function(covar) {
      test_covariate(datasets[[day]], covar, test = "wilcox")$wilcox %>%
        mutate(dataset = day)
    })
  })
)

# View results
regression_results
wilcox_results
```
Now, let's run LASSO regressions to see if there is any of the features that predicts BSI:

```{r}
library(glmnet)

run_lasso <- function(df, response_col = "case", feature_start_col = 7, alpha = 1) {
  # Prepare data
  y <- as.numeric(df[[response_col]])
  X <- as.matrix(df[, feature_start_col:ncol(df)])
  colnames(X) <- colnames(df)[feature_start_col:ncol(df)]
  
  # Remove columns with all zeros or NAs
  nonzero_cols <- which(colSums(X, na.rm = TRUE) != 0)
  X <- X[, nonzero_cols, drop = FALSE]
  
  # Remove rows with NA in response
  keep <- !is.na(y)
  y <- y[keep]
  X <- X[keep, , drop = FALSE]
  
  # Fit LASSO logistic regression with cross-validation
  cvfit <- cv.glmnet(X, y, family = "binomial", alpha = alpha, standardize = TRUE)
  
  # Get coefficients at lambda.min
  coef_min <- coef(cvfit, s = "lambda.min")
  selected_features <- rownames(coef_min)[which(coef_min != 0)]
  selected_features <- setdiff(selected_features, "(Intercept)")
  
  list(
    cvfit = cvfit,
    selected_features = selected_features,
    coef = coef_min
  )
}

# Example usage for casecontrol_fam_7day
lasso_fam_7day <- run_lasso(casecontrol_fam_7day)
print(lasso_fam_7day$selected_features)

# You can repeat for other datasets:
lasso_fam_substrate_7day <- run_lasso(casecontrol_fam_substrate_7day, log_transform = F)
lasso_subfam_7day <- run_lasso(casecontrol_subfam_7day, log_transform = F)
lasso_pul_7day <- run_lasso(casecontrol_pul_7day, log_transform = F)
lasso_ec_7day <- run_lasso(casecontrol_ec_7day, log_transform = F)
```


```{r}
glm_fructan <- glm(case ~ cellulose, 
                   data = casecontrol_fam_substrate_7day, 
                   family = binomial)

summary(glm_fructan)

ggplot(casecontrol_fam_substrate_20day, aes(x = factor(case), y = log10(Bacteroides_s_lat+0.000001))) +
  geom_boxplot(outlier.shape = NA) +
  geom_jitter(width = 0.2, alpha = 0.7, color = "blue") +
  labs(
    x = "Case Status (0 = Control, 1 = Case)",
    y = "GH32_e57 Abundance",
    title = "GH32_e57 Abundance by Case Status"
  ) +
  theme_minimal()
```

## Carbohydrate degradation potential in gut-microbiome taxa across the tree of life

### PUL predictions across isabl1 MAGs

We'll work with the bins recovered from the isabl1 metagenomes using multi-sample sample binning with VAMB (successfull metaspades assemblies used in enterococcus_diversity_II). Let's symlink the MAG directory:

```{sh}
ln -s /data1/xavierj/carlos/bsi_prediction/analyses/enterococcus_diversity_II/binning/short/isabl1/vamb/multi_bins /data1/xavierj/carlos/bsi_prediction/analyses/bacteroides_pul/mags
```

Now, we run CheckM2 on all the bins:

```{sh}
sbatch code/scripts/bacteroides_pul/checkm2_isabl1.sh
```

With the CheckM results and the GTDB results I obtained for the Enterococcus projects for these bins, we can now select a subset of MAGs on which to do the PUL predictions:

```{r}
# Load the CheckM2 and GTDB reports
gtdb <- read_delim("analyses/enterococcus_diversity_II/binning/short/isabl1/gtdb/gtdbtk.bac120.summary.tsv")
checkm <- read_delim("analyses/bacteroides_pul/checkm2/quality_report.tsv")

# Join the reports, starting with the GTDB which includes only the MAGs from Bacteria and split the classification string
full_report <- left_join(gtdb, checkm, by = c("user_genome" = "Name")) %>%
  separate(classification,
           into = c("domain", "phylum", "class", "order", "family", "genus", "species"),
           sep = ";",
           fill = "right",
           remove = FALSE) %>%
  mutate(across(c(domain, phylum, class, order, family, genus, species),
                ~ sub("^[a-z]__","", .))) %>%
  mutate(family = case_when(
                            str_detect(genus, "revotella") ~ "Prevotellaceae",
                            TRUE ~ family
  ))

# Get list of MAGs with >90% completion and <10% contamination
nc_mags <- full_report %>%
  filter(Contamination <= 10 & Completeness >= 90 & Contig_N50 >= 50000) %>%
  pull(user_genome) %>%
  unique

write(nc_mags, "analyses/bacteroides_pul/isabl1_nc_mags.txt")
```

By filtering MAGs with >90% completeness, <10% contamination, and contig N50 >= 50,000 bp, we en up with 10360 MAGs from 980 species out of 1578 (~62%) of all species detected. All 10 major phyla and ~70-80% of all other taxonomic ranks are represented in this set.

Now, let's predict CGCs and PULs for those selected MAGs:

```{bash, eval=FALSE}
sbatch code/scripts/bacteroides_pul/isabl1_mags_dbcan_1-9999.sh # 6000821
sbatch code/scripts/bacteroides_pul/isabl1_mags_dbcan_10000-10360.sh # 6001620
```

And then predict the signal peptides of the CGC proteins:

```{bash, eval=FALSE}
sbatch code/scripts/bacteroides_pul/isabl1_mags_signalp_1-9999.sh # 6702650
sbatch code/scripts/bacteroides_pul/isabl1_mags_signalp_10000-10360.sh # 6720114
```

### Comparing CGC content across bacterial families

We start by compiling the results of the CGC predictions across all MAGs:

```{bash, eval=FALSE}
# Directory for results
mkdir -p analyses/bacteroides_pul/mag_pul_summary

# Ins and outs
NC_MAGS="analyses/bacteroides_pul/isabl1_nc_mags.txt"
CGC_OUT="analyses/bacteroides_pul/mag_pul_summary/compiled_cgcs.tsv"

# Get header from first file that exists
FIRST_MAG=$(head -n 1 ${NC_MAGS})
FIRST_FILE="analyses/bacteroides_pul/mag_pul_prediction/isabl1/${FIRST_MAG}/cgc_standard_out.tsv"

# Write header with added 'mag' column
echo -e "mag\t$(head -n 1 ${FIRST_FILE})" > ${CGC_OUT}

# Process each MAG
while IFS= read -r MAG; do
    TSV_FILE="analyses/bacteroides_pul/mag_pul_prediction/isabl1/${MAG}/cgc_standard_out.tsv"
    
    if [ -f "${TSV_FILE}" ]; then
        # Add MAG column and append data (skip header)
        tail -n +2 ${TSV_FILE} | awk -v mag="${MAG}" 'BEGIN{OFS="\t"} {print mag, $0}' >> ${CGC_OUT}
        echo "Processed: ${MAG}"
    else
        echo "Warning: File not found for ${MAG}"
    fi
done < ${NC_MAGS}
```

and also compiling the results of signalP across all MAGs:

```{bash, eval=FALSE}
# Compiled output
SIG_OUT="analyses/bacteroides_pul/mag_pul_summary/compiled_signalp.tsv"

# Get header from first file that exists
FIRST_MAG=$(head -n 1 ${NC_MAGS})
FIRST_FILE="analyses/bacteroides_pul/mag_pul_prediction/isabl1/${FIRST_MAG}/signalp/prediction_results.txt"

# Write header with added 'mag' column (using sed to get exactly line 2)
echo -e "mag\t$(sed -n '2p' ${FIRST_FILE})" > ${SIG_OUT}

# Process each MAG
while IFS= read -r MAG; do
    TSV_FILE="analyses/bacteroides_pul/mag_pul_prediction/isabl1/${MAG}/signalp/prediction_results.txt"
    
    if [ -f "${TSV_FILE}" ]; then
        # Add MAG column and append data (skip header)
        tail -n +3 ${TSV_FILE} | awk -v mag="${MAG}" 'BEGIN{OFS="\t"} {print mag, $0}' >> ${SIG_OUT}
        echo "Processed: ${MAG}"
    else
        echo "Warning: File not found for ${MAG}"
    fi
done < ${NC_MAGS}
```

Now, we can integrate the CGC CAZyme predictions, the singalP predictions, the MAG taxonomy, and assembly QC report: 

```{r}
# For loading large tables
library(data.table)

# Load the compiled CGC and signalP results
compiled_cgc <- fread("analyses/bacteroides_pul/mag_pul_summary/compiled_cgcs.tsv")
compiled_signalp <- fread("analyses/bacteroides_pul/mag_pul_summary/compiled_signalp.tsv") %>%
  separate(`# ID`, into = c("temp", "cgc", "protein_id"), sep = "\\|", remove = TRUE, extra = "drop") %>%
  select(mag, cgc, protein_id, Prediction)

# Integrate cazyme and signalP data
cazyme_data <- compiled_cgc %>%
  group_by(mag, `CGC#`) %>%
  filter(!any(str_detect(`Gene Annotation`, "GT"))) %>%
  ungroup() %>%
  filter(`Gene Type` == "CAZyme") %>%
  mutate( # Extract cazyme subfam string for catalytic subfamilies
    cazy_subfam = case_when(
    str_count(`Gene Annotation`, "\\|") == 1 ~ str_split_i(`Gene Annotation`, "\\|", 2),
    str_detect(`Gene Annotation`, "GH|PL|CE") ~ {
      fields <- str_split(`Gene Annotation`, "\\|", simplify = TRUE)[1,]
      target_field <- fields[str_detect(fields, "GH|PL|CE")][1]
      str_remove(target_field, "\\+.*$")
    },
    TRUE ~ str_remove(`Gene Annotation`, "^[^|]*\\|")
    )
  ) %>%
  filter(str_detect(cazy_subfam, "GH|PL|CE")) %>% # Filter to catabolic CAZymes
  mutate( # Get cazyme fam
    cazy_fam = str_remove(cazy_subfam, "_.*")
  ) %>% # Get cazy type
  mutate(
    cazy_type = str_extract(cazy_fam, "GH|PL|CE")
    ) %>% # Add signalP predictions
  left_join(
    select(compiled_signalp, mag, protein_id, Prediction),
    by = c("Protein ID" = "protein_id", "mag")) %>% 
  left_join( # Add taxonomy and assembly statistics
    select(full_report, user_genome, domain, phylum, class, order, family, genus, species, Completeness, Contamination, Contig_N50, Genome_Size, Total_Contigs, Max_Contig_Length),
    by = c("mag" = "user_genome")
  )

head(cazyme_data)
```

Let's make sure the joining worked properly; there shuold be 501,943 entries and no NAs:

```{r}
# Check for NAs in key columns
na_summary <- cazyme_data %>%
  summarise(
    na_cazy_subfam = sum(is.na(cazy_subfam)),
    na_cazy_fam = sum(is.na(cazy_fam)),
    na_cazy_type = sum(is.na(cazy_type)),
    na_Prediction = sum(is.na(Prediction)),
    na_genus = sum(is.na(genus)),
    na_family = sum(is.na(family)),
    total_rows = n()
  )
print(na_summary)
```

Now, I can summarize the CAZyme and polysaccharide potential at the family level:

```{r}
# Summarize total CGCs per MAG
cgcs_per_mag <- cazyme_data %>%
  group_by(mag) %>%
  summarise(n_CGCs = n_distinct(`CGC#`))

# Summarize total CAZymes per cazy_type per MAG
cazymes_per_type <- cazyme_data %>%
  group_by(mag, cazy_type) %>%
  summarise(n_cazymes = n(), .groups = "drop") %>%
  pivot_wider(names_from = cazy_type, values_from = n_cazymes, names_prefix = "n_", values_fill = 0)

# Summarize number of CGCs per MAG with at least one CAZyme with a signal peptide
cgcs_signalp_per_mag <- cazyme_data %>%
  filter(Prediction != "OTHER") %>%
  group_by(mag) %>%
  summarise(n_CGCs_signalp = n_distinct(`CGC#`))

# Summarize CAZymes per cazy_type with signal peptide (Prediction != "OTHER")
cazymes_signalp <- cazyme_data %>%
  filter(Prediction != "OTHER") %>%
  group_by(mag, cazy_type) %>%
  summarise(n_cazymes_signalp = n(), .groups = "drop") %>%
  pivot_wider(names_from = cazy_type, values_from = n_cazymes_signalp, names_prefix = "n_signalp_", values_fill = 0)

# Compile MAG level summaries
mag_cazy_summary <- cgcs_per_mag %>%
  left_join(cazymes_per_type, by = "mag") %>%
  left_join(cazymes_signalp, by = "mag") %>%
  left_join(cgcs_signalp_per_mag, by = "mag") %>%
  left_join(
    full_report %>%
      select(user_genome, domain, phylum, class, order, family, genus, species, Completeness, Contamination, Contig_N50, Genome_Size, Total_Contigs, Max_Contig_Length),
    by = c("mag" = "user_genome")
  ) %>%
  mutate(
    n_CGCs_signalp = replace_na(n_CGCs_signalp, 0),
    across(starts_with("n_signalp_"), ~replace_na(., 0))
  )
```

Let's download the bac120 tree and metadata from GTDB release 226 to use as a baseline for plotting the cazyme information:

```{bash, eval = FALSE}
curl -o analyses/bacteroides_pul/mag_pul_summary/bac120_r226.tree https://data.ace.uq.edu.au/public/gtdb/data/releases/release226/226.0/bac120_r226.tree
curl -o analyses/bacteroides_pul/mag_pul_summary/bac120_taxonomy_r226.tsv https://data.ace.uq.edu.au/public/gtdb/data/releases/release226/226.0/bac120_taxonomy_r226.tsv
curl -o analyses/bacteroides_pul/mag_pul_summary/bac120_metadata_r226.tsv.gz https://data.ace.uq.edu.au/public/gtdb/data/releases/latest/bac120_metadata.tsv.gz
```

We will do the summaries at the family level, so we need to subset the GTDB tree to the families included in our MAGs:

```{r}
library(ape)
library(treeio)

# Load the tree and taxonomy
bac120_tree <- read.tree("analyses/bacteroides_pul/mag_pul_summary/bac120_r226.tree")
bac120_taxonomy <- read_delim("analyses/bacteroides_pul/mag_pul_summary/bac120_taxonomy_r226.tsv", col_names = FALSE, delim = "\t") %>%
  rename(genome = X1, taxonomy = X2) %>%
  separate(taxonomy,
           into = c("domain", "phylum", "class", "order", "family", "genus", "species"),
           sep = ";",
           fill = "right",
           remove = FALSE) %>%
  mutate(across(c(domain, phylum, class, order, family, genus, species),
                ~ sub("^[a-z]__", "", .))) %>%
  mutate(family = case_when(
                            str_detect(genus, "revotella") ~ "Prevotellaceae",
                            TRUE ~ family
  ))

# Get list of target families
families <- full_report %>% 
  filter(Contamination <= 10 & Completeness >= 90 & Contig_N50 >= 50000 & family != "UBA932") %>% 
  pull(family) %>%
  unique

# Key between target genome labels and taxonomy
family_genomes_key <- bac120_taxonomy %>%
  filter(family %in% families & genome %in% bac120_tree$tip.label) %>%
  group_by(family) %>%
  slice_sample(n = 1) %>%
  ungroup()

# Target genome labels for filtering
family_genomes <-family_genomes_key %>%
  pull(genome)

# Subset tree to genomes from target family
family_tree <- keep.tip(bac120_tree, family_genomes)
```

Let's now integrate the tree data with the family genome key and create the base tree plot:

```{r}
library(ggtree)

# Tree plot with tip labels as family names
family_tree_plot <- ggtree(family_tree) %<+% family_genomes_key +
  geom_tiplab(aes(label = family), size = 3, align = TRUE)

# Add label key to cazy data for plotting
plot_data <-  mag_cazy_summary %>%
  left_join(family_genomes_key %>% select(family, genome), by = "family")
```

I made a function to plot the distributions of cazymes and CGCs to align to the family tree:

```{r}
# Function to make th percentile plot
make_percentile_plot <- function(summary_data, variable, tip_order, phylum_col = "phylum", genome_col = "genome", dot_color = "#252eb0", line_color = "gray50") {
  var_sym <- rlang::ensym(variable)
  phylum_sym <- rlang::ensym(phylum_col)
  genome_sym <- rlang::ensym(genome_col)
  
  # Filter and order data by tree tip order
  plot_df <- summary_data %>%
    filter(.data[[rlang::as_string(genome_sym)]] %in% tip_order) %>%
    mutate(y_plot = factor(.data[[rlang::as_string(genome_sym)]], levels = tip_order)) %>%
    group_by(y_plot, !!phylum_sym) %>%
    summarise(
      median = median(!!var_sym, na.rm = TRUE),
      p2.5 = quantile(!!var_sym, 0.025, na.rm = TRUE),
      p97.5 = quantile(!!var_sym, 0.975, na.rm = TRUE),
      .groups = "drop"
    )
  
  # Calculate phylum boundaries based on tip order
  phylum_bounds <- plot_df %>%
    group_by(!!phylum_sym) %>%
    summarise(
      top = min(as.numeric(y_plot)),
      bottom = max(as.numeric(y_plot)),
      label_genome = y_plot[which.min(as.numeric(y_plot))],
      .groups = "drop"
    )
  
  # Plot
  p <- ggplot(plot_df, aes(y = y_plot)) +
    geom_linerange(aes(xmin = p2.5, xmax = p97.5), size = 1, color = line_color) +
    geom_point(aes(x = median), size = 2, color = dot_color) +
    labs(x = rlang::as_label(var_sym), y = NULL) +
    theme_minimal(base_size = 10) +
    theme(
      axis.text.y = element_blank(), 
      axis.title.y = element_blank(),
      axis.text.x = element_text(color = "black"),
      panel.border = element_rect(color = "black", fill = NA, linewidth = 0.75)
    )
  
  # Add horizontal lines between phyla (except after last)
  if (nrow(phylum_bounds) > 1) {
    for (i in seq_len(nrow(phylum_bounds) - 1)) {
      p <- p + geom_hline(yintercept = phylum_bounds$bottom[i] + 0.5, linetype = "dotted", color = "gray40")
    }
  }
  
  # Add phylum labels aligned with the top taxon in each phylum
  p <- p + geom_text(
    data = phylum_bounds,
    aes(x = -Inf, y = top, label = !!phylum_sym),
    hjust = -0.1, vjust = 0.5, size = 3, fontface = "bold", inherit.aes = FALSE
  )
  
  return(p)
}
```

Now, let's generate the plots for GHs, PLs, CGCs, with and without signal peptides:

```{r}
library(aplot)

# Get tip labels ordered by their y coordinate (as plotted)
tree_data <- family_tree_plot$data
tip_order <- tree_data %>%
  filter(isTip) %>%
  arrange(y) %>%
  pull(label)

# Make all iqr plots for all variables
cgc_iqr <- make_percentile_plot(plot_data, n_CGCs, tip_order)
gh_iqr <- make_percentile_plot(plot_data, n_GH, tip_order)
pl_iqr <- make_percentile_plot(plot_data, n_PL, tip_order)
signalp_cgc_iqr <- make_percentile_plot(plot_data, n_CGCs_signalp, tip_order)
signalp_gh_iqr <- make_percentile_plot(plot_data, n_signalp_GH, tip_order)
signalp_pl_iqr <- make_percentile_plot(plot_data, n_signalp_PL, tip_order)

# Align iqr plots to the left of the tree
cgc_iqr_plot <- cgc_iqr %>% insert_left(family_tree_plot, width = 0.75)
gh_iqr_plot <- gh_iqr %>% insert_left(family_tree_plot, width = 0.75)
pl_iqr_plot <- pl_iqr %>% insert_left(family_tree_plot, width = 0.75)
signalp_cgc_iqr_plot <- signalp_cgc_iqr %>% insert_left(family_tree_plot, width = 0.75)
signalp_gh_iqr_plot <- signalp_gh_iqr %>% insert_left(family_tree_plot, width = 0.75)
signalp_pl_iqr_plot <- signalp_pl_iqr %>% insert_left(family_tree_plot, width = 0.75)

# Save plots
ggsave("document/plots/cgc_iqr.pdf", cgc_iqr_plot, width = 9, height = 9)
ggsave("document/plots/gh_iqr.pdf", gh_iqr_plot, width = 9, height = 9)
ggsave("document/plots/pl_iqr.pdf", pl_iqr_plot, width = 9, height = 9)
ggsave("document/plots/signalp_cgc_iqr.pdf", signalp_cgc_iqr_plot, width = 9, height = 9)
ggsave("document/plots/signalp_gh_iqr.pdf", signalp_gh_iqr_plot, width = 9, height = 9)
ggsave("document/plots/signalp_pl_iqr.pdf", signalp_pl_iqr_plot, width = 9, height = 9)
```

### Dynamics of Bacteroidota families following antibiotic exposure

Based on the previous comparison, the families in the phylum Bacteroidota are clearly the ones with the highest content of CGCs with potential for extracellular polysaccharide degradation. That includes some families that seem common, such as Tannerellaceae and Rikenellaceae. Now, I want to test whether there is differential prevalence of taxa in this phylum after the antibiotic prophylaxis to determine what lineages beyond Bacteroides with high CGC content could also engage in cooperative polysaccharide breakdown in our patients. For that, I performed a linear mixed regression of detection (>0.1% relative abundance) of each family after at least one day of quinolone prophylaxis and plotted the family-specific coefficients:

```{r}
library(lme4)
library(broom.mixed)

# Get family-level relative abundances
tblrel_family_meta <- prep_taxa_counts("family")

# Define target families and abundance columns
target_families <- c("Bacteroidaceae", "Barnesiellaceae", "Dysgonomonadaceae", "Marinifilaceae", "Rikenellaceae", "Tannerellaceae", "Prevotellaceae")
abund_cols <- paste0(target_families, "_abund")

# For each patient, determine first day of quinolone exposure
quin_start <- tblpatientday_clinical %>%
  filter(quinolones == 1 & DayRelativeToNearestHCT <= 30) %>%
  group_by(PatientID) %>%
  summarise(first_quin_day = min(DayRelativeToNearestHCT, na.rm = TRUE))

# Subset to samples up to day 30 after HCT
tbl_prevalence <- tblrel_family_meta %>%
  filter(DayRelativeToNearestHCT <= 30) %>% # Subset to samples up to day 30 after HCT
  # Merge with clinical table to get quinolone exposure
  left_join(tblpatientday_clinical %>% select(PatientID, DayRelativeToNearestHCT, quinolones), 
            by = c("PatientID", "DayRelativeToNearestHCT")) %>% 
  left_join(quin_start, by = "PatientID") %>%
  # Annotate each sample as pre- or post-prophylaxis
  mutate(
    prophylaxis_status = case_when(
      is.na(first_quin_day) ~ "pre", # never received quinolones
      DayRelativeToNearestHCT < first_quin_day ~ "pre",
      DayRelativeToNearestHCT >= (first_quin_day + 1) ~ "post",
      TRUE ~ NA_character_
    )
  ) %>%
  filter(!is.na(prophylaxis_status) & prophylaxis_status %in% c("pre", "post"))

# Set reference level for prophylaxis_status to "pre"
tbl_prevalence$prophylaxis_status <- factor(tbl_prevalence$prophylaxis_status, levels = c("pre", "post"))

# For each family, create a binary prevalence column (1 if abundance >= 0.001, else 0)
for (fam in target_families) {
  col <- paste0(fam, "_abund")
  prev_col <- paste0(fam, "_prev")
  tbl_prevalence[[prev_col]] <- as.integer(tbl_prevalence[[col]] >= 0.001)
}

# Store the models (not summaries)
prevalence_results <- list()

for (fam in target_families) {
  prev_col <- paste0(fam, "_prev")
  dat <- tbl_prevalence %>%
    filter(!is.na(.data[[prev_col]]), !is.na(prophylaxis_status))
  
  # Fit model and store the MODEL OBJECT (not summary)
  model <- glmer(
    formula = as.formula(paste(prev_col, "~ prophylaxis_status + (1|PatientID)")),
    data = dat,
    family = binomial
  )
  
  prevalence_results[[fam]] <- model  # Store model, not summary(model)
}

# Now extract effects with broom.mixed
prevalence_effects <- bind_rows(
  lapply(names(prevalence_results), function(fam) {
    mod <- prevalence_results[[fam]]
    tidy_mod <- broom.mixed::tidy(mod, effects = "fixed", conf.int = TRUE)
    tidy_mod %>%
      filter(term == "prophylaxis_statuspost") %>%
      mutate(family = fam)
  })
)

# Plot (log odds ratio)
bacteroidota_detection <- ggplot(prevalence_effects, aes(x = factor(family, levels = c("Prevotellaceae", "Bacteroidaceae", "Tannerellaceae", "Rikenellaceae", "Barnesiellaceae", "Marinifilaceae", "Dysgonomonadaceae")), y = estimate, ymin = conf.low, ymax = conf.high)) +
  geom_pointrange(size = 0.3) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "gray50") +
  labs(
    x = "Family",
    y = "Effect of prophylaxis on detection (>0.1%)"
  ) +
  custom_theme+
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# Save the plot
ggsave("document/plots/bacteroidota_prophylaxis_effect.pdf", width = 3.5, height = 5)
```

Let's also plot the distribution of median relative abundances per patient after quinolone prophylaxis for each family: 

```{r}  
# Calculate median abundance per patient for each family
patient_medians <- post_tbl %>%
  filter(prophylaxis_status == "post") %>%
  select(PatientID, all_of(paste0(target_families, "_abund"))) %>%
  pivot_longer(
    cols = ends_with("_abund"),
    names_to = "family",
    values_to = "abundance"
  ) %>%
  mutate(family = str_remove(family, "_abund$")) %>%
  group_by(PatientID, family) %>%
  summarise(median_abundance = median(abundance, na.rm = TRUE), .groups = "drop")

# Plot distributions
bacteroidota_fam_abund <- ggplot(patient_medians, 
  aes(x = factor(family,levels = c("Bacteroidaceae", "Tannerellaceae", "Prevotellaceae", "Rikenellaceae", "Barnesiellaceae", "Marinifilaceae", "Dysgonomonadaceae")),
    y = log10(median_abundance + 1e-5))) +
  geom_boxplot(outlier.shape = NA, alpha = 0.7, fill = "gray75") +
  geom_jitter(width = 0.2, alpha = 0.2, color = "gray20") +
  labs(
  x = "Family",
  y = "log10(median relative abundance per patient)"
  ) +
  custom_theme +
  theme(legend.position = "none",
        axis.text.x = element_text(angle = 45, hjust = 1))

# Save plot
ggsave("document/plots/bacteroidota_fam_abund.pdf", bacteroidota_fam_abund, width = 4, height = 5)
```

And run a Friedman test and paired Wilcoxon signed-rank test between all pairs of families to compare:

```{r}
# Pivot to wide format for the Friedman test (one row per patient, one column per family)
patient_medians_wide <- patient_medians %>%
  pivot_wider(names_from = family, values_from = median_abundance)

# Friedman test
friedman_data <- patient_medians_wide %>%
  select(-PatientID)
friedman_matrix <- as.matrix(friedman_data)
friedman_result <- friedman.test(friedman_matrix)

# Paired Wilcoxon signed-rank tests for all family pairs
family_names <- colnames(friedman_matrix)
wilcox_results <- combn(family_names, 2, simplify = FALSE, FUN = function(pair) {
  test <- wilcox.test(
    friedman_matrix[, pair[1]],
    friedman_matrix[, pair[2]],
    paired = TRUE,
    exact = FALSE
  )
  tibble(
    family1 = pair[1],
    family2 = pair[2],
    p.value = test$p.value,
    statistic = test$statistic
  )
}) %>% bind_rows()

# Adjust p-values for multiple testing (FDR)
wilcox_results <- wilcox_results %>%
  mutate(p.adj = p.adjust(p.value, method = "fdr"))

# Print results
print(friedman_result)
print(wilcox_results)
```

Now let's make a bar plot showing the number of patients in which each family has relative abundance >= 0.1 in at least one sample post prophylaxis:

```{r}
# For each patient and family, check if any sample has abundance >= 0.1
patient_family_present <- tbl_prevalence %>%
  filter(prophylaxis_status == "post") %>%
  select(PatientID, all_of(paste0(target_families, "_abund"))) %>%
  pivot_longer(
    cols = ends_with("_abund"),
    names_to = "family",
    values_to = "abundance"
  ) %>%
  mutate(family = str_remove(family, "_abund$")) %>%
  group_by(PatientID, family) %>%
  summarise(present = any(abundance >= 0.1, na.rm = TRUE), .groups = "drop")

# Count number of patients per family (including 0 for families with no patients meeting condition)
family_patient_counts <- patient_family_present %>%
  filter(present) %>%
  group_by(family) %>%
  summarise(n_patients = n_distinct(PatientID)) %>%
  ungroup() %>%
  # Ensure all target families are included, filling with 0 if missing
  right_join(tibble(family = target_families), by = "family") %>%
  mutate(n_patients = replace_na(n_patients, 0))

# Bar plot
bacteroidota_fam_0.1 <- ggplot(family_patient_counts, 
  aes(x = factor(family, levels = c("Bacteroidaceae", "Tannerellaceae", "Prevotellaceae", "Rikenellaceae", "Barnesiellaceae", "Marinifilaceae", "Dysgonomonadaceae")), 
      y = n_patients)) +
  geom_col(alpha = 0.7, fill = "gray75", color = "black") +
  geom_text(aes(label = n_patients), vjust = -0.5, size = 3) +
  labs(
    x = "Family",
    y = "Patients with â‰¥ 10% rel. abundance post-prophylaxis"
  ) +
  custom_theme +
  theme(legend.position = "none",
        axis.text.x = element_text(angle = 45, hjust = 1))

# Save the plot
ggsave("document/plots/bacteroidota_fam_0.1.pdf", bacteroidota_fam_0.1, width = 4, height = 5)
```

### Dissecting CGC content variation within the family Bacteroidaceae

Let's start by subsetting the GTDB tree to the Bacteroidaceae taxa in our dataset:

```{r}
# Get list of target species
bacteroidaceae_spp <- full_report %>% 
  filter(Contamination <= 10 & Completeness >= 90 & Contig_N50 >= 50000 & family == "Bacteroidaceae" & species != "") %>% 
  pull(species) %>%
  unique

# Key between target genome labels and taxonomy
bacteroidaceae_genomes_key <- bac120_taxonomy %>%
  #filter(order == "Bacteroidales" & genome %in% bac120_tree$tip.label) %>%
  filter(species %in% bacteroidaceae_spp & genome %in% bac120_tree$tip.label) %>%
  group_by(species) %>%
  slice_sample(n = 1) %>%
  ungroup()

# Target genome labels for filtering
bacteroidaceae_genomes <-bacteroidaceae_genomes_key %>%
  pull(genome)

# Subset tree to genomes from target family
bacteroidaceae_tree <- keep.tip(bac120_tree, bacteroidaceae_genomes)
```

Now, let's integrate the tree data with the family genome key and create the base tree plot:

```{r}
# Tree plot with tip labels as family names
bacteroidaceae_tree_plot <- ggtree(bacteroidaceae_tree) %<+% bacteroidaceae_genomes_key +
  geom_tiplab(aes(label = species), size = 3, align = F)

# Add label key to cazy data for plotting
bacteroidaceae_plot_data <-  mag_cazy_summary %>%
  left_join(bacteroidaceae_genomes_key %>% select(species, genome), by = "species")
```

And now we can plot the distribution of CGCs across species of the Bacteroidaceae:

```{r}
# Get tip labels ordered by their y coordinate (as plotted)
bacteroidaceae_tip_order <- bacteroidaceae_tree_plot$data %>%
  filter(isTip) %>%
  arrange(y) %>%
  pull(label)

# Make all iqr plots for all variables
bacteroidaceae_cgc_iqr <- make_percentile_plot(bacteroidaceae_plot_data, n_CGCs, bacteroidaceae_tip_order)
bacteroidaceae_gh_iqr <- make_percentile_plot(bacteroidaceae_plot_data, n_GH, bacteroidaceae_tip_order)
bacteroidaceae_pl_iqr <- make_percentile_plot(bacteroidaceae_plot_data, n_PL, bacteroidaceae_tip_order)
bacteroidaceae_signalp_cgc_iqr <- make_percentile_plot(bacteroidaceae_plot_data, n_CGCs_signalp, bacteroidaceae_tip_order)
bacteroidaceae_signalp_gh_iqr <- make_percentile_plot(bacteroidaceae_plot_data, n_signalp_GH, bacteroidaceae_tip_order)
bacteroidaceae_signalp_pl_iqr <- make_percentile_plot(bacteroidaceae_plot_data, n_signalp_PL, bacteroidaceae_tip_order)

# Align iqr plots to the left of the tree
bacteroidaceae_cgc_iqr_plot <- bacteroidaceae_cgc_iqr %>% insert_left(bacteroidaceae_tree_plot, width = 0.75)
bacteroidaceae_gh_iqr_plot <- bacteroidaceae_gh_iqr %>% insert_left(bacteroidaceae_tree_plot, width = 0.75)
bacteroidaceae_pl_iqr_plot <- bacteroidaceae_pl_iqr %>% insert_left(bacteroidaceae_tree_plot, width = 0.75)
bacteroidaceae_signalp_cgc_iqr_plot <- bacteroidaceae_signalp_cgc_iqr %>% insert_left(bacteroidaceae_tree_plot, width = 0.75)
bacteroidaceae_signalp_gh_iqr_plot <- bacteroidaceae_signalp_gh_iqr %>% insert_left(bacteroidaceae_tree_plot, width = 0.75)
bacteroidaceae_signalp_pl_iqr_plot <- bacteroidaceae_signalp_pl_iqr %>% insert_left(bacteroidaceae_tree_plot, width = 0.75)
```

These plots dissect the variation in content across the family but they show that *B. fragilis* is one of the speces with the lowest CGC content. Perhaps looking at the predicted PUL substrates or the presence of SusC/SusD homologs would reveal more differences.

### PUL substrate diversity among Bacteroidaceae species



### Substrates

```{r}
filter(cazyme_data, Prediction != "OTHER" & cazy_type == "GH") %>%
  pull(cazy_fam) %>%
  unique()

```


## TRASH

```{r}
#TRASH


case_patients <- proteobsi_isabl1_7day # or _7day, _20day

case_samples <- tblASVsamples %>%
  filter(PatientID %in% case_patients, isabl1 == TRUE) %>%
  inner_join(first_proteo, by = "PatientID") %>%
  mutate(day_diff = first_infection_day - DayRelativeToNearestHCT) %>%
  filter(day_diff >= 0) %>%
  group_by(PatientID) %>%
  slice_min(order_by = day_diff, n = 1, with_ties = FALSE) %>%
  ungroup() %>%
  select(PatientID, SampleID, DayRelativeToNearestHCT, first_infection_day, day_diff)

# Add clinical phase and sex
case_samples <- case_samples %>%
  left_join(tblpatientday_clinical %>% select(PatientID, DayRelativeToNearestHCT, clinical_phase, sex),
            by = c("PatientID", "DayRelativeToNearestHCT"))

# Prepare control pool: patients with metagenomic samples, no Proteobacteria infection
control_pool <- tblASVsamples %>%
  filter(isabl1 == TRUE, !PatientID %in% proteobsi_isabl1_all) %>%
  left_join(tblpatientday_clinical %>% select(PatientID, DayRelativeToNearestHCT, clinical_phase, sex, Proteobacteria_infection),
            by = c("PatientID", "DayRelativeToNearestHCT")) %>%
  filter(Proteobacteria_infection == 0 | is.na(Proteobacteria_infection))

# For each case, randomly select 4 matched controls by clinical_phase and sex
set.seed(1830)
matched_case_controls <- case_samples %>%
  rowwise() %>%
  mutate(
    control_samples = list({
      phase <- clinical_phase
      sex_ref <- sex
      control_pool %>%
        filter(clinical_phase == phase, sex == sex_ref) %>%
        sample_n(size = min(4, n()), replace = FALSE) %>%
        select(PatientID, SampleID, DayRelativeToNearestHCT, clinical_phase, sex)
    })
  ) %>%
  unnest(control_samples, names_sep = "_control") %>%
  ungroup()

# Combine into a single dataset
case_control_data <- bind_rows(
  case_samples %>%
    mutate(case = TRUE) %>%
    select(PatientID, SampleID, DayRelativeToNearestHCT, clinical_phase, sex, case),
  matched_case_controls %>%
    mutate(case = FALSE) %>%
    select(PatientID = control_samples_controlPatientID,
           SampleID = control_samples_controlSampleID,
           DayRelativeToNearestHCT = control_samples_controlDayRelativeToNearestHCT,
           clinical_phase = control_samples_controlclinical_phase,
           sex = control_samples_controlsex,
           case)
) #%>%
  #left_join(tblrel_genus_meta, by = c("PatientID", "SampleID"))

```